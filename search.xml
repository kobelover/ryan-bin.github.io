<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Go Web Examples》中文翻译]]></title>
    <url>%2F2017%2F10%2F22%2FGoWebExamples%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[本文是GO中国社区发起翻译的文章，由本人翻译。github项目地址访问这里.原英文访问这里 Hello WorldIntroductionGo 是一个自带干粮的编程语言，拥有自己的内置webserver.标准库中的net/http 包包含了关于HTTP协议的全部功能的函数。包中包含了一个HTTP client和 一个HTTP server . 在本例子中你将会发现成功创建一个你可以在浏览器中浏览网页的webserver是有多么简单。 Registering a Request Handle首先，创建一个从浏览器接受进来的HTTP链接、HTTP client 或者API请求的Handler， 在Go 中是一个函数，它在创建的时候，形态上有如下相似特点1func (w http.ResponseWriter, r *http.Request) 这个函数接受两个参数： http.ResponseWriter: 这个参数是给你写你的text/html响应的http.Request : 它包含所有HTTP请求的信息，比如URL 或者 header注册一个的HTTP Server 的request handler 非常简单，如下就是：123http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "Hello, you've requested: %s\n", r.URL.Path)&#125;) Listen for HTTP Connections一个单独的request handler不能接受任何外部的HTTP 链接。一个HTTP Server,为了把链接发送给request handle， 它必须监听一个端口。由于80端口是大多数默认的HTTP 流量通道， 所以本server也会用80端口来监控。下面的代码会启动一个GO的默认HTTP server ,同时监听80端口上的链接。你可以在你的浏览器中访问http://localhost/, 同时可以看到你的server正在处理你的request:1http.ListenAndServe(":80", nil) The Code (for copy/paste)下面是完整的代码1234567891011121314package mainimport ( "fmt" "net/http")func main() &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "Hello, you've requested: %s\n", r.URL.Path) &#125;) http.ListenAndServe(":80", nil)&#125; Routing (using gorilla/mux)introductionGo 的net/http 包提供了许多HTTP协议功能的函数。有一件事件，它还做的不够好，比如对于复杂的请求路由把请求的url分割成单个参数。幸运的是，在Go的社区里，有一个非常流行的package 来解决这个问题。在本例中，你将会看到如何用 gorilla/mux以命名参数、GET/POST Hander 和域名限制的形式来创建路由 Installing the gorilla/mux packagegorilla/mux 在写web 应用时，它带来了许多特性来提升生产效率。它在创建的时候，形态上和GO原始创建request handler 在创建形式上相似:func (w http.ResponseWriter, r *http.Request).所以这个包可以和其他HTTP 库混合使用，比如middleware 或已经存在的应用。通过 go get从 Github 上下载安装： go get -u github.com/gorilla/mux Creating a new Router首先创建一个新的路由。对于你的web应用，这个路由是主路由，它会传递参数到你的server.它会接受所有的HTTP链接，同时发送到你注册的request handler 上。你可以像下面一下创建：1r := mux.NewRouter() Registering a Request Handler当你已经创建了一个路由，你可以像内置包那样注册request handler.唯一不同的是，调用 http.HandleFunc(...)时，你可以用r.HandleFunc(...) 来代替 URL Parametersgorilla/mux 路由最具有能量的地方是从请求的URL上提取信息。作为一个例子，比如下面是你应用的URL:1/books/go-programming-blueprint/page/10 这个URL有两个动态部分：121.Book 的标题（go-programming-blueprint）2.页数(10) 对于上面提到的URL,在处理request handler时， 你可以如下处理，来做动态参数处理：1234r.HandleFunc("/books/&#123;title&#125;/page/&#123;page&#125;", func(w http.ResponseWriter, r *http.Request) &#123; // get the book // navigate to the page&#125;) 最后一件事就是从动态参数中获取数据。这个包提供一个函数mux.Vars(r) ,它把http.Request作为一个参数，并把动态参数以map的形式返回 12345func(w http.ResponseWriter, r *http.Request) &#123; vars := mux.Vars(r) vars["title"] // the book title slug vars["page"] // the page&#125; Setting the HTTP server’s router想知道nil 在http.ListenAndServe(&quot;:80&quot;, nil) 的意义？它是HTTP server d的主路由的参数。默认情况下，它是nil， 它表示用net/http包的默认路由。 为了利用你自己的路由，用你的路由参数r 取代 nil1http.ListenAndServe(&quot;:80&quot;, r) The Code (for copy/paste)下面是全部的代码123456789101112131415161718192021package mainimport ( "fmt" "net/http" "github.com/gorilla/mux")func main() &#123; r := mux.NewRouter() r.HandleFunc("/books/&#123;title&#125;/page/&#123;page&#125;", func(w http.ResponseWriter, r *http.Request) &#123; vars := mux.Vars(r) title := vars["title"] page := vars["page"] fmt.Fprintf(w, "You've requested the book: %s on page %s\n", title, page) &#125;) http.ListenAndServe(":80", r)&#125; Features of the gorilla/mux RouterMethods将请求方法指定为HTTP 方法1234r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, CreateBook).Methods(&quot;POST&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, ReadBook).Methods(&quot;GET&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, UpdateBook).Methods(&quot;PUT&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, DeleteBook).Methods(&quot;DELETE&quot;) Hostnames &amp; Subdomains对特定的hostname或子域名做限制 1r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, BookHandler).Host(&quot;www.mybookstore.com&quot;) Schemes将请求限制为http/https12r.HandleFunc(&quot;/secure&quot;, SecureHandler).Schemes(&quot;https&quot;)r.HandleFunc(&quot;/insecure&quot;, InsecureHandler).Schemes(&quot;http&quot;) Path Prefixes &amp; Subrouters将请求限定为特定的路径123bookrouter := r.PathPrefix(&quot;/books&quot;).Subrouter()bookrouter.HandleFunc(&quot;/&quot;, AllBooks)bookrouter.HandleFunc(&quot;/&#123;title&#125;&quot;, GetBook) TemplatesIntroductionGo 的html/template包对HTML模板提供了丰富的模板语言。它主要用于Web应用程序，在客户端的浏览中以结构化的方式显示数据。Go 模板语言最大的好处就是数据的自动转义。没有必要担心在显示浏览器之前，那些作为GO解析HTML模板的XSS攻击和避开所有输入。 First TemplateGO写一个模板非常简单。这个例子展示一个TODO 列表, 用HTML中的无序列表 （ul）来写， 当渲染模板时， 可以从GO的各种数据结构中导入。它可以是简单的string 或 数字， 它甚至可以是嵌套的数据结构。要访问模板中的数据，最前的变量是通过&#123;&#123; &#125;&#125; 来访问。其中 花括号中的点(.) 称为管道和root12345678data := TodoPageData&#123; PageTitle: "My TODO list", Todos: []Todo&#123; &#123;Title: "Task 1", Done: false&#125;, &#123;Title: "Task 2", Done: true&#125;, &#123;Title: "Task 3", Done: true&#125;, &#125;,&#125; 12345678910&lt;h1&gt;&#123;&#123;.PageTitle&#125;&#125;&lt;h1&gt;&lt;ul&gt; &#123;&#123;range .Todos&#125;&#125; &#123;&#123;if .Done&#125;&#125; &lt;li class="done"&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;li&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;end&#125;&#125; &#123;&#123;end&#125;&#125;&lt;/ul&gt; Control Structures模板语言包含一组丰富的控制结构来渲染HTML.这里你将会看到一些最常用的。更详细的清单访问text/template|Control Structure | Definition|—|—|&#123;&#123;/ a comment /&#125;&#125; | Defines a comment||&#123;&#123;.&#125;&#125; | Renders the root element||&#123;&#123;.Title&#125;&#125; | Renders the “Title”-field in a nested element||&#123;&#123;if .Done&#125;&#125; &#123;&#123;else&#125;&#125; &#123;&#123;end&#125;&#125; | Defines an if-Statement||&#123;&#123;range .Todos&#125;&#125; &#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125; | Loops over all “Todos” and renders each using &#123;&#123;.&#125;&#125;||&#123;&#123;block “content” .&#125;&#125; &#123;&#123;end&#125;&#125; | Defines a block with the name “content”| Parsing Templates from Files模板可以是从一个字符串或者磁盘上的文件解析。通常下，模板是来自磁盘。这个example 展示了如何来操作。在这个例子，下面GO程序中，有一个模板名字为layout.html123tmpl, err := template.ParseFiles("layout.html")// ortmpl := template.Must(template.ParseFiles("layout.html")) Execute a Template in a Request Handler模板从磁盘解析后，就可以在请求处理程序中使用它。Execute 函数接受一个写入模板的io.Writer和一个将数据传递到模板中的 interface {} 。当被一个http.ResponseWriter 调用时. Content-Type 是被自动设置在HTTP response 中123func(w http.ResponseWriter, r *http.Request) &#123; tmpl.Execute(w, "data goes here")&#125; The Code (for copy/paste)下面是全部代码12345678910111213141516171819202122232425262728293031323334package mainimport ( "html/template" "net/http")type Todo struct &#123; Title string Done bool&#125;type TodoPageData struct &#123; PageTitle string Todos []Todo&#125;func main() &#123; tmpl := template.Must(template.ParseFiles("layout.html")) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; data := TodoPageData&#123; PageTitle: "My TODO list", Todos: []Todo&#123; &#123;Title: "Task 1", Done: false&#125;, &#123;Title: "Task 2", Done: true&#125;, &#123;Title: "Task 3", Done: true&#125;, &#125;, &#125; tmpl.Execute(w, data) &#125;) http.ListenAndServe(":80", nil)&#125; 12345678910&lt;h1&gt;&#123;&#123;.PageTitle&#125;&#125;&lt;h1&gt;&lt;ul&gt; &#123;&#123;range .Todos&#125;&#125; &#123;&#123;if .Done&#125;&#125; &lt;li class="done"&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;li&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;end&#125;&#125; &#123;&#123;end&#125;&#125;&lt;/ul&gt; Forms这个例子将演示如何模拟联系人表单并将其解析为结构12345678910111213141516171819202122232425262728293031323334353637// forms.gopackage mainimport ( "html/template" "net/http")type ContactDetails struct &#123; Email string Subject string Message string&#125;func main() &#123; tmpl := template.Must(template.ParseFiles("forms.html")) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; if r.Method != http.MethodPost &#123; tmpl.Execute(w, nil) return &#125; details := ContactDetails&#123; Email: r.FormValue("email"), Subject: r.FormValue("subject"), Message: r.FormValue("message"), &#125; // do something with details _ = details tmpl.Execute(w, struct&#123; Success bool &#125;&#123;true&#125;) &#125;) http.ListenAndServe(":8080", nil)&#125; 123456789101112131415&lt;!-- forms.html --&gt;&#123;&#123;if .Success&#125;&#125; &lt;h1&gt;Thanks for your message!&lt;/h1&gt;&#123;&#123;else&#125;&#125; &lt;h1&gt;Contact&lt;/h1&gt; &lt;form method="POST"&gt; &lt;label&gt;Email:&lt;/label&gt;&lt;br /&gt; &lt;input type="text" name="email"&gt;&lt;br /&gt; &lt;label&gt;Subject:&lt;/label&gt;&lt;br /&gt; &lt;input type="text" name="subject"&gt;&lt;br /&gt; &lt;label&gt;Message:&lt;/label&gt;&lt;br /&gt; &lt;textarea name="message"&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type="submit"&gt; &lt;/form&gt;&#123;&#123;end&#125;&#125; Assets and Files这个例子将展示如何使用静态文件比如CSS、 JavaScripts或图片1234567891011// static-files.gopackage mainimport "net/http"func main() &#123; fs := http.FileServer(http.Dir("assets/")) http.Handle("/static/", http.StripPrefix("/static/", fs)) http.ListenAndServe(":8080", nil)&#125; 1234$ tree assets/assets/└── css └── styles.css 123456$ go run static-files.go$ curl -s http://localhost:8080/static/css/styles.cssbody &#123; background-color: black;&#125; Middleware (Basic)这个例子将展示如何在GO中创建基本的日志中间件。一个中间件只需要一个 http.HandlerFunc 作为它其中的一个参数，装饰它，并返回一个新的http.HandlerFunc用于服务器调用123456789101112131415161718192021222324252627282930// basic-middleware.gopackage mainimport ( "fmt" "log" "net/http")func logging(f http.HandlerFunc) http.HandlerFunc &#123; return func(w http.ResponseWriter, r *http.Request) &#123; log.Println(r.URL.Path) f(w, r) &#125;&#125;func foo(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "foo")&#125;func bar(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "bar")&#125;func main() &#123; http.HandleFunc("/foo", logging(foo)) http.HandleFunc("/bar", logging(bar)) http.ListenAndServe(":8080", nil)&#125; 12345678$ go run basic-middleware.go2017/02/10 23:59:34 /foo2017/02/10 23:59:35 /bar2017/02/10 23:59:36 /foo?bar$ curl -s http://localhost:8080/foo$ curl -s http://localhost:8080/bar$ curl -s http://localhost:8080/foo?bar Middleware (Advanced)这个例子将展示如何在GO中创建更高级的中间件。一个中间件只需要一个http.HandlerFunc 作为它的一个参数，装饰它并把它作为一个新的 http.HandlerFunc 给服务器调用 在这里，我们定义一个新的类型Middleware, 它可以更容易的链接多个中间件。这个想法灵感来自于Mat Ryer 谈论如果建立APIs.你可以从这里 查看更详细的这个片段详细展示了如何创建一个新的中间件。此处下面是完整的例子，这里我们减少了一些样板代码。123456789101112131415161718192021unc createNewMiddleware() Middleware &#123; // Create a new Middleware middleware := func(next http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc which is called by the server eventually handler := func(w http.ResponseWriter, r *http.Request) &#123; // ... do middleware things // Call the next middleware/handler in chain next(w, r) &#125; // Return newly created handler return handler &#125; // Return newly created middleware return middleware&#125; 下面是完整的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// advanced-middleware.gopackage mainimport ( "fmt" "log" "net/http" "time")type Middleware func(http.HandlerFunc) http.HandlerFunc// Logging logs all requests with its path and the time it took to processfunc Logging() Middleware &#123; // Create a new Middleware return func(f http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc return func(w http.ResponseWriter, r *http.Request) &#123; // Do middleware things start := time.Now() defer func() &#123; log.Println(r.URL.Path, time.Since(start)) &#125;() // Call the next middleware/handler in chain f(w, r) &#125; &#125;&#125;// Method ensures that url can only be requested with a specific method, else returns a 400 Bad Requestfunc Method(m string) Middleware &#123; // Create a new Middleware return func(f http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc return func(w http.ResponseWriter, r *http.Request) &#123; // Do middleware things if r.Method != m &#123; http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return &#125; // Call the next middleware/handler in chain f(w, r) &#125; &#125;&#125;// Chain applies middlewares to a http.HandlerFuncfunc Chain(f http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc &#123; for _, m := range middlewares &#123; f = m(f) &#125; return f&#125;func Hello(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "hello world")&#125;func main() &#123; http.HandleFunc("/", Chain(Hello, Method("GET"), Logging())) http.ListenAndServe(":8080", nil)&#125; 12345678$ go run advanced-middleware.go2017/02/11 00:34:53 / 0s$ curl -s http://localhost:8080/hello world$ curl -s -XPOST http://localhost:8080/Bad Request Sessions这个例子将会展示如何通过流行的gorilla/sessions包，存储session cookiescookie 是存储在用户浏览器中的小数据，并在每次请求时发送到服务器。在它们中，我们可以存储用户是否登录到我们的网站，并找出它时间上是谁（在我们系统中）在本例中，我们只允许经过身份验证在/secret 页上查看隐私的信息。要访问它，首先要访问/login得到有效的会话cookie.此外，他可以访问/logout 来注销我们访问私密信息的权限12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// sessions.gopackage mainimport ( "fmt" "net/http" "github.com/gorilla/sessions")var ( // key must be 16, 24 or 32 bytes long (AES-128, AES-192 or AES-256) key = []byte("super-secret-key") store = sessions.NewCookieStore(key))func secret(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Check if user is authenticated if auth, ok := session.Values["authenticated"].(bool); !ok || !auth &#123; http.Error(w, "Forbidden", http.StatusForbidden) return &#125; // Print secret message fmt.Fprintln(w, "The cake is a lie!")&#125;func login(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Authentication goes here // ... // Set user as authenticated session.Values["authenticated"] = true session.Save(r, w)&#125;func logout(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Revoke users authentication session.Values["authenticated"] = false session.Save(r, w)&#125;func main() &#123; http.HandleFunc("/secret", secret) http.HandleFunc("/login", login) http.HandleFunc("/logout", logout) http.ListenAndServe(":8080", nil)&#125; 12345678910$ go run sessions.go$ curl -s http://localhost:8080/secretForbidden$ curl -s -I http://localhost:8080/loginSet-Cookie: cookie-name=MTQ4NzE5Mz...$ curl -s --cookie "cookie-name=MTQ4NzE5Mz..." http://localhost:8080/secretThe cake is a lie! JSON本例将展示如何使用encoding/json包来编码和解码 JSON文件的1234567891011121314151617181920212223242526272829303132333435// json.gopackage mainimport ( "encoding/json" "fmt" "net/http")type User struct &#123; Firstname string `json:"firstname"` Lastname string `json:"lastname"` Age int `json:"age"`&#125;func main() &#123; http.HandleFunc("/decode", func(w http.ResponseWriter, r *http.Request) &#123; var user User json.NewDecoder(r.Body).Decode(&amp;user) fmt.Fprintf(w, "%s %s is %d years old!", user.Firstname, user.Lastname, user.Age) &#125;) http.HandleFunc("/encode", func(w http.ResponseWriter, r *http.Request) &#123; peter := User&#123; Firstname: "John", Lastname: "Doe", Age: 25, &#125; json.NewEncoder(w).Encode(peter) &#125;) http.ListenAndServe(":8080", nil)&#125; 1234567$ go run json.go$ curl -s -XPOST -d'&#123;"firstname":"Donald","lastname":"Trump","age":70&#125;' http://localhost:8080/decodeDonald Trump is 70 years old!$ curl -s http://localhost:8080/encode&#123;"firstname":"John","lastname":"Doe","age":25&#125; Websockets这个例子将展示如何使用Websockets。我们将建立一个简单的server,它发回我们发给它所有的内容。这里我们用go get来下载gorilla/websocket1go get github.com/gorilla/websocket 下面是全部的代码123456789101112131415161718192021222324252627282930313233343536373839404142// websockets.gopackage mainimport ( "fmt" "net/http" "github.com/gorilla/websocket")var upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024,&#125;func main() &#123; http.HandleFunc("/echo", func(w http.ResponseWriter, r *http.Request) &#123; conn, _ := upgrader.Upgrade(w, r, nil) // error ignored for sake of simplicity for &#123; // Read message from browser msgType, msg, err := conn.ReadMessage() if err != nil &#123; return &#125; // Print the message to the console fmt.Printf("%s sent: %s\n", conn.RemoteAddr(), string(msg)) // Write message back to browser if err = conn.WriteMessage(msgType, msg); err != nil &#123; return &#125; &#125; &#125;) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; http.ServeFile(w, r, "websockets.html") &#125;) http.ListenAndServe(":8080", nil)&#125; 12345678910111213141516171819202122&lt;!-- websockets.html --&gt;&lt;input id="input" type="text" /&gt;&lt;button onclick="send()"&gt;Send&lt;/button&gt;&lt;pre id="output"&gt;&lt;/pre&gt;&lt;script&gt; var input = document.getElementById("input"); var output = document.getElementById("output"); var socket = new WebSocket("ws://localhost:8080/echo"); socket.onopen = function () &#123; output.innerHTML += "Status: Connected\n"; &#125;; socket.onmessage = function (e) &#123; output.innerHTML += "Server: " + e.data + "\n"; &#125;; function send() &#123; socket.send(input.value); input.value = ""; &#125;&lt;/script&gt; 12$ go run websockets.go[127.0.0.1]:53403 sent: Hello Go Web Examples, you're doing great! ###Password Hashing (bcrypt)这个例子将展示如何使用bcrypt 来hash 密码，获取package:1$ go get golang.org/x/crypto/bcrypt 从现在开始，我们编写的每个应用程序都利用这个库1234567891011121314151617181920212223242526272829// passwords.gopackage mainimport ( &quot;fmt&quot; &quot;golang.org/x/crypto/bcrypt&quot;)func HashPassword(password string) (string, error) &#123; bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err&#125;func CheckPasswordHash(password, hash string) bool &#123; err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil&#125;func main() &#123; password := &quot;secret&quot; hash, _ := HashPassword(password) // ignore error for the sake of simplicity fmt.Println(&quot;Password:&quot;, password) fmt.Println(&quot;Hash: &quot;, hash) match := CheckPasswordHash(password, hash) fmt.Println(&quot;Match: &quot;, match)&#125; 1234$ go run passwords.goPassword: secretHash: $2a$14$ajq8Q7fbtFRQvXpdCq7Jcuy.Rx1h/L4J60Otx.gyNLbAYctGMJ9tKMatch: true]]></content>
      <categories>
        <category>-翻译</category>
      </categories>
      <tags>
        <tag>-翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java和python中的Concurrent包的future异步]]></title>
    <url>%2F2017%2F09%2F17%2Fjava%E5%92%8Cpython%E4%B8%AD%E7%9A%84Concurrent%E5%8C%85%E7%9A%84future%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本文主要阐述了java和python中concurrent包下的future异步，对于python中的concurrent.futures是在借鉴java的java.util.concurrent包的思想而成，然而python多线程中又有GIL的限制，所以下面就来看看两个语言下的concurrent下的future异同 接口的简单认识java中的future 是java.util.concurrent包下面的一个接口，该接口定义如下源码12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Python定义的是一个类源码123456789101112131415161718192021class Future(object): """Represents the result of an asynchronous computation.""" def __init__(self): self._condition = threading.Condition() self._state = PENDING self._result = None self._exception = None self._waiters = [] self._done_callbacks = [] def _invoke_callbacks(self): def __repr__(self): def cancelled(self): def running(self): def done(self): def __get_result(self): def add_done_callback(self, fn): def result(self, timeout=None): def exception(self, timeout=None): def set_running_or_notify_cancel(self): def set_result(self, result): def set_exception(self, exception): 语言特性带来的差异java在定义的时候定义的是一个接口，进行规范，在实现上比较自由，比如spring 框架的并发包：org.springframework.util.concurrent 就是继承Future这个抽象类。python定义的是一个类(虽然有abc但没用)，也就是在实现的时候，虽然可以去继承，但是为了解除冗余性，往往自己重新去实现了一下Future, 比如 asyncio.Future就是重新设计的，所以这一点来说java面向接口编程特点比Python还是要强很多，在面对各种并发问题的时候，java优势就更加明显 相同点两个语言 Future 可以从 Executor（java 是Executors）下的submit() 实例化得到， 但是java的特性，Executors提供更丰富的接口 java 的Executors接口：python的Executor接口： python 的concurrent.futures 却只有ProcessPoolExecutor和ThreadPoolExecutor， 目的也简单，前者主要解决 CPU密集问题，后者主要解决IO密集问题，因为在执行阻塞型 I/O 操作的函数， 在等待操作系统返回结果时都会释放 GIL， 所以Python中的多线程此刻才体现优势（相对于串行而言） 下面来简单的实验一下java的实现:123456789101112131415161718192021222324252627282930313233import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class demo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; final int processors = Runtime.getRuntime().availableProcessors(); final ExecutorService exec = Executors.newFixedThreadPool(processors); Callable call = new Callable()&#123; public String call() throws Exception&#123; System.out.println("Hey, Man! this is thread1!!"); Thread.sleep(1000 * 3); return "This is thread1 and result is string, you can return other object"; &#125; &#125;; Future thead1 = exec.submit(call); //主线程设置了2秒，thead1 要sleep 3秒，但是两者是同时执行的 Thread.sleep(1000 * 2); System.out.println("this is main thread "); //其他不重要的事情 String res = (String) thead1.get(); System.out.println(res); //关闭线程池 exec.shutdown(); /* 打印：*/ //Hey, Man! this is thread1!! //this is main thread //This is thread1 and result is string, you can return other object &#125;&#125; python的实现：12345678910111213141516# coding=utf-8import concurrent.futuresimport timedef task(): print("Hey, Man! this is thread1!!") return "This is thread1 and result is string, you can return other object"def learn(): with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor: time.sleep(3) thread1 = executor.submit(task) print(thread1.result())if __name__ == '__main__': learn() 同时可以通过下面的代码来比较一下python中的ProcessPoolExecutor和ThreadPoolExecutor ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# coding=utf-8import concurrent.futuresimport datetimeclass Number(object): """Number class""" def __init__(self): super(Number, self).__init__() self.futures = set() @property def one_func(self): for i in range(1, 10): yield i @property def two_func(self): for i in range(1, 10): yield i*2 @property def three_func(self): for i in range(1, 10): yield i*3 def n_func(self, n): def inner(): for i in range(1, 10): yield i*n return set(inner()) def share_value(self, n): """ 用于检测一个变量在并发中是否共享 """ def inner(): for i in range(1, 10): yield i return self.futures.update(set(inner())) # ThreadPoolExecutor def learn(self): start_time = datetime.datetime.now() with concurrent.futures. ThreadPoolExecutor(max_workers=8) as executor: tasks = [self.one_func, self.two_func, self.three_func] future_task = &#123;executor.submit(task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] for i in number: print(i) end_time = datetime.datetime.now() print(end_time - start_time) #range(1, 10): 0:00:00.001001 range(1, 100000): 0:00:01.386313 # ProceessProolExecutor def train(self): start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.n_func, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] print(number) print(future.result()) end_time = datetime.datetime.now() print(end_time-start_time) # range(1, 10):0:00:00.297790 range(1, 100000): 0:00:00.465234 # 在并发中因为开启了多个 interpreter, 所以数据是不共享的 def con_shared_value_test(self): ''' 此处用的是实例化开始的时候就加入的变量作为接受数据变量 ''' start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.share_value, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] print(number) # n print(future.result()) # None end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时： 0:00:00.308821 range(1, 100000) 耗时： 0:00:00.060158 # 多线程把数据发到一个变量 def multiThread_share_value(self): start_time = datetime.datetime.now() with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor: tasks = [self.one_func, self.two_func, self.three_func] future_task = &#123;executor.submit(task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] self.futures.update(set(number)) end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时： 0:00:00.001977 range(1, 100000) 耗时： 0:00:00.049100 # 多进程把数据发到一个变量 def multiProcess_share_value(self): start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.n_func, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] self.futures.update(set(future.result())) end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时：耗时： 0:00:00.297792 range(1, 100000) 耗时： 0:00:00.402069if __name__ == '__main__': n = Number() n.multiProcess_share_value() print(n.futures) 需求现在我们设定一个需求, 来看看两个语言下的future解决同一个问题是怎么处理的。需求是从各大网站爬取一些免费的代理IP,因为爬取的时候。各个任务在跑的时候是不相关的，所以我们可以用异步来执行这些，现在我们决定爬取的网站如下： http://www.xicidaili.com/nn/http://www.66ip.cn/http://www.nianshao.me/ 编码实现javajava在实现任务的时候，采用的spring boot, 但还是代码量太多，于是贴出只核心部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import com.legotime.constant.Constants;import com.legotime.domain.ProxyIP;import com.legotime.util.ProxyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import java.util.*;import java.util.concurrent.*;/*** 从网络爬取代理IP*/@Configurationpublic class FreeProxy &#123; private static final Logger log = LoggerFactory.getLogger(FreeProxy.class); public HashSet&lt;ProxyIP&gt; ipSet = new HashSet&lt;ProxyIP&gt;(); public FreeProxy() &#123; &#125; /** * 爬取 http://www.xicidaili.com/nn/ 的免费代理 * @return */ @Async private Future&lt;String&gt; getXicidaili()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.xicidaili.com/nn/ 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.XICI_URL, Constants.XICI_PAGE, Constants.XICI_PAGE_SUF, Constants.XICI_1Feature, Constants.XICI_2Feature, Constants.XICI_IPIndex, Constants.XICI_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.xicidaili.com/nn/ 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.xicidaili.com/ 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; /** * 爬取 http://www.66ip.cn/ 的免费代理 * @return */ @Async private Future&lt;String&gt; getIp66()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.66ip.cn/ 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.IP66_URL, Constants.IP66_PAGE, Constants.IP66_PAGE_SUF, Constants.IP66_1Feature, Constants.IP66_2Feature, Constants.IP66_IPIndex, Constants.IP66_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.66ip.cn/ 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.66ip.cn/ 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; /** * 爬取 http://www.nianshao.me 的免费代理 * @return */ @Async public Future&lt;String&gt; getNiaoshao()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.nianshao.me 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.NIANSHAO_URL, Constants.NIANSHAO_PAGE, Constants.NIANSHAO_PAGE_SUF, Constants.NIANSHAO_1Feature, Constants.NIANSHAO_2Feature, Constants.NIANSHAO_IPIndex, Constants.NIANSHAO_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.nianshao.me 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.nianshao.me 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; public void Train()&#123; long start = System.currentTimeMillis(); log.info("爬取代理任务开始，开始时间："+start); Future&lt;String&gt; xicidaili = getXicidaili(); Future&lt;String&gt; ip66 = getIp66(); while (true)&#123; if (getXicidaili().isDone() &amp;&amp; getIp66().isDone() &amp;&amp; getNiaoshao().isDone()) &#123; break; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; long end = System.currentTimeMillis(); log.info("爬取代理任务结束，结束时间："+end); log.info("任务全部完成总耗时"+(end-start)+"毫秒"); &#125; public HashSet&lt;ProxyIP&gt; GetAllIpProxy()&#123; Train(); return ipSet; &#125;&#125; python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from utils.configUtil import constantfrom utils.spiderUtil import getFreeProxyimport concurrent.futuresimport datetimefrom utils.logUtil import Logclass GetWebProxy(object): """收集互联网的零散IP""" def __init__(self): super(GetWebProxy, self).__init__() self.cons = constant() self.futures = set() def get_xicidaili(self): return getFreeProxy( self.cons.xicidaili_url, self.cons.xicidaili_page, self.cons.xicidaili_page_suf, self.cons.xicidaili_1Feature, self.cons.xicidaili_2Feature, self.cons.xicidaili_ip_index, self.cons.xicidaili_post_index ) def get_ip66(self): return getFreeProxy( self.cons.ip66_url, self.cons.ip66_page, self.cons.ip66_page_suf, self.cons.ip66_1Feature, self.cons.ip66_2Feature, self.cons.ip66_ip_index, self.cons.ip66_post_index ) def get_nianshao(self): return getFreeProxy( self.cons.ip66_url, self.cons.ip66_page, self.cons.ip66_page_suf, self.cons.ip66_1Feature, self.cons.ip66_2Feature, self.cons.ip66_ip_index, self.cons.ip66_post_index ) def contro_func(self, task_func): return task_func def train(self): start_time = datetime.datetime.now() with concurrent.futures.ThreadPoolExecutor(max_workers=8) as exeutor: tasks = [self.get_xicidaili(), self.get_ip66(), self.get_nianshao()] future_task = &#123;exeutor.submit(self.contro_func, task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): # ip_ports = future_task[future] self.futures.update(set(future.result())) end_time = datetime.datetime.now() print("耗时：", (end_time-start_time)) # range(1, 10):耗时：耗时： 0:00:00.297792 range(1, 100000) 耗时： 0:00:00.402069if __name__ == '__main__': g = GetWebProxy() g.train() print(g.futures)]]></content>
      <categories>
        <category>-日常开发</category>
      </categories>
      <tags>
        <tag>-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGD、SGD和MBGD的一些区别]]></title>
    <url>%2F2017%2F09%2F12%2FBGD%E3%80%81SGD%E5%92%8CMBGD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[梯度下降(Batch gradient descent)–BGD123456789101112131415161718192021# 梯度下降(Batch gradient descent)--BGDdef batch_gradient_descent(x, y, learn_rate, epoches): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ theta = np.array([0.0, 0.0]) for i in range(epoches): loss = [0.0, 0.0] # 全部的值带入，计算 梯度 m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 随机梯度下降(Stochastic gradient descent)–SGD12345678910111213141516171819202122232425262728293031323334353637383940414243# 这不是随机梯度，随机梯度是每迭代一次，数据就随机一次---但是这也是一种处理手段def stochastic_gradient_descent_false(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] return batch_gradient_descent(x, y, learn_rate, epoches)# 正确的随机梯度应该是这样def stochastic_gradient_descent_true(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ theta = np.array([0.0, 0.0]) for i in range(epoches): shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] # 随机之后的值，进行梯度计算 loss = [0.0, 0.0] m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 小批量梯度下降(Mini-batch gradient descent)–MBGD1234567891011121314151617181920212223242526272829def mini_batch_gradient_descent(x, y, learn_rate, epoches, mini_length): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :param mini_length: mini batch length :return: """ # 随机打乱----optional theta = np.array([0.0, 0.0]) # 随机打乱数据 ----optional shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:, 0] x = shufflle_data[:, 1:3] for i in range(epoches): # 0-min_length， mini_length+1 2mini_length, ....... 一小段，一小段距离用于一次优化迭代 loss = [0.0, 0.0] for j in range(0, len(y), mini_length): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / mini_length loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / mini_length # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# -*- coding: utf-8 -*-# @Date : 2017/9/8# @Author : ryanbing (legotime@qq.com)import numpy as npimport matplotlib.pyplot as pltimport datetimerng = np.random.RandomState(1)x = 10 * rng.rand(500)y = 3 * x + 2 + rng.randn(500)# plt.scatter(x, y)# plt.show()# 找出 y = wx + b 中的w 和 b, 正确的应该是 w = 3, b = 2# 我们在计算的时候其看成 y = WX 其中 W= [w, b], X = [x, 1].T# 梯度下降(Batch gradient descent)--BGDdef batch_gradient_descent(x, y, learn_rate, epoches): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() theta = np.array([0.0, 0.0]) for i in range(epoches): loss = [0.0, 0.0] # 全部的值带入，计算 梯度 m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, theta# 这不是随机梯度，随机梯度是每迭代一次，数据就随机一次---但是这也是一种处理手段def stochastic_gradient_descent_false(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] end_time = datetime.datetime.now() return end_time - start_time, batch_gradient_descent(x, y, learn_rate, epoches)# 正确的随机梯度应该是这样def stochastic_gradient_descent_true(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() theta = np.array([0.0, 0.0]) for i in range(epoches): shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] # 随机之后的值，进行梯度计算 loss = [0.0, 0.0] m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, theta# 小批量梯度下降(Mini-batch gradient descent)--MBGDdef mini_batch_gradient_descent(x, y, learn_rate, epoches, mini_length): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :param mini_length: mini batch length :return: """ start_time = datetime.datetime.now() # 随机打乱----optional theta = np.array([0.0, 0.0]) # 随机打乱数据 ----optional shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:, 0] x = shufflle_data[:, 1:3] for i in range(epoches): # 0-min_length， mini_length+1 2mini_length, ....... 一小段，一小段距离用于一次优化迭代 loss = [0.0, 0.0] for j in range(0, len(y), mini_length): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / mini_length loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / mini_length # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, thetadef contro_func(func, **kwargs): """ :param func: 函数 :param kwargs: func 中需要的参数 :return: """ x = kwargs.get('x', None) y = kwargs.get('y', None) learn_rate = kwargs.get('learn_rate', None) epoches = kwargs.get('epoches', None) stochastic_rate = kwargs.get('stochastic_rate', None) mini_length = kwargs.get('mini_length', None) # change the value is args is not num if stochastic_rate is not None: return func(x, y, learn_rate, epoches, stochastic_rate) if mini_length is not None: return func(x, y, learn_rate, epoches, mini_length) return func(x, y, learn_rate, epoches)def show_trend(): # 画出收敛的的图像和收敛对应的时间 rng = np.random.RandomState(1) x = 10 * rng.rand(500) x = np.array([x, np.ones(500)]).T y = 3 * x + 2 + rng.randn(500) learn_rate = 0.01 stochastic_rate = 0.4 mini_length = 10 for j in [batch_gradient_descent, stochastic_gradient_descent_false, stochastic_gradient_descent_true, mini_batch_gradient_descent]: tmp = [] for epoches in [1, 10, 100, 1000, 10000, 100000]: tmp.append(contro_func(i, x=x, y=y, learn_rate=learn_rate, stochastic_rate=stochastic_rate, mini_length=mini_length, epoches=epoches))if __name__ == '__main__': # test(func=func, x=1, y=2, learn_rate=3, epoches=4, stochastic_rate=5) # print(batch_gradient_descent(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100000)) # [ 1.14378512 0.17288215] # [ 3.18801281 0.50870366] # [ 3.18602557 0.806018 ] # [ 3.03276102 1.84267445] # [ 3.01449298 1.96623647] # [ 3.01449298 1.96623647] # print(stochastic_gradient_descent_false(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100,stochastic_rate=0.4)) # [ 1.11939055 0.16949282] # [ 3.19877639 0.50404936] # [ 3.20921332 0.78698163] # [ 3.04720128 1.82412805] # [ 3.01920995 1.89883629] # [ 2.98281143 2.15226071] # print(stochastic_gradient_descent_true(np.array([x, np.ones(50000)]).T, y, learn_rate=0.01, epoches=1000,stochastic_rate=1)) # print(mini_batch_gradient_descent(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100, mini_length=10)) # [ 0.94630842 0.14845568] # [ 0.8811451 0.15444328] # [ 3.18337012 0.51049921] # [ 3.14833317 0.79174635] # [ 3.03507147 1.87931184]]]></content>
      <categories>
        <category>-机器学习</category>
      </categories>
      <tags>
        <tag>-参数优化</tag>
      </tags>
  </entry>
</search>
