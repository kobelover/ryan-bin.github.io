<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析Java Restful API的数据结构构造]]></title>
    <url>%2F2018%2F01%2F22%2FAPI%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[浅析Java Restful API的数据结构构造下面从java的基本类型、引用类型以及一些常用数据结构出发，实验了各自的返回结果。同时给出了一些常用的日常封装。 数据类型基本数据类型(byte, short,char, int, long, float, double, boolean) 返回的都是一个值，比如 123 基本数据类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091@RequestMapping(value = "/basic")@RestControllerpublic class HelloWorld &#123; /** * byte 数据类型是8位、有符号的，以二进制补码表示的整数 * 最小值是 -128（-2^7), 最大值是 127（2^7-1), 默认为0 * byte 变量占用的空间只有 int 类型的四分之一 * @return */ @RequestMapping(value = "/byte") public byte getByte() &#123; byte res = Byte.MAX_VALUE; return res; &#125; /** * short 数据类型是 16 位、有符号的以二进制补码表示的整数 * 最小值是 -32768（-2^15）最大值是 32767（2^15 - 1 * short变量是int型变量所占空间的二分之一 * @return */ @RequestMapping(value = "/short") public short getShort() &#123; short res = Short.MAX_VALUE; return res; &#125; /** * int 数据类型是32位、有符号的以二进制补码表示的整数 * 最小值是 -2,147,483,648（-2^31）, 最大值是 2,147,483,647（2^31 - 1） * @return */ @RequestMapping(value = "/int") public int get_int() &#123; int res = Integer.MAX_VALUE; return res; &#125; /** * long 数据类型是 64 位、有符号的以二进制补码表示的整数 * 最小值是 -9,223,372,036,854,775,808（-2^63） * 最大值是 9,223,372,036,854,775,807（2^63 -1） * @return */ @RequestMapping(value = "/long") public long get_long() &#123; long res = Long.MAX_VALUE; return res; &#125; /** * float 数据类型是单精度、32位、符合IEEE 754标准的浮点数 * @return */ @RequestMapping(value = "/float") public float get_float() &#123; float res = Float.MAX_VALUE; return res; &#125; /** * double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数 * @return */ @RequestMapping(value = "/double") public double get_double() &#123; double res = Double.MIN_VALUE; return res; &#125; @RequestMapping(value = "/boolean") public boolean get_boolean() &#123; boolean res = false; return res; &#125; /** * char类型是一个单一的 16 位 Unicode 字符 * @return */ @RequestMapping(value = "/char") public char get_char() &#123; char res = Character.MAX_VALUE; return res; &#125;&#125; 返回值，分别为：1234567812732767214748364792233720368547758073.4028235e+385e-324false&quot;￿&quot; 引用数据类型引用数据类型包含了类(class),接口(interface), 数组(array)12345678910111213141516171819202122232425public class Author &#123; private String name; private String ID; public Author(String name, String ID) &#123; this.name = name; this.ID = ID; &#125; // get set&#125;public class Book &#123; private Integer id; private String bookname; private Author author; public Book(Integer id, String bookname, Author author) &#123; this.id = id; this.bookname = bookname; this.author = author; &#125; // &#125; 123public interface Iaction &#123; String getString();&#125; 123456public class IactionImpl implements Iaction&#123; @Override public String getString() &#123; return "this is IactionImpl method"; &#125;&#125; 123456public interface Iaction2 &#123; String getString1(); String getString2();&#125; 123456789101112public class Iaction2Impl implements Iaction2&#123; @Override public String getString1() &#123; return "this is getString1"; &#125; @Override public String getString2() &#123; return "this is getString1"; &#125;&#125; Controller 层123456789101112131415161718192021222324252627282930313233@RequestMapping(value = &quot;/reference&quot;)@RestControllerpublic class Reference &#123; @RequestMapping(value = &quot;/class/book&quot;) public Book getBook() &#123; Author ryan = new Author(&quot;ryan&quot;, &quot;001&quot;); Book book = new Book(1, &quot;java入门到放弃&quot;, ryan); return book; &#125; @RequestMapping(value = &quot;/interface/action&quot;) public Iaction getAction() &#123; Iaction iaction = new IactionImpl(); return iaction; &#125; @RequestMapping(value = &quot;/interface/action2&quot;) public Iaction2 getAction2() &#123; Iaction2 iaction = new Iaction2Impl(); return iaction; &#125; @RequestMapping(value = &quot;/array/strings&quot;) public String[] getStringArray() &#123; String[] strings = new String[3]; strings[0] = &quot;are&quot;; strings[1] = &quot;you&quot;; strings[2] = &quot;ok&quot;; return strings; &#125;&#125; req:http://localhost:8080/reference/class/book 返回值： 12345678&#123; "id": 1, "bookname": "java入门到放弃", "author": &#123; "name": "ryan", "id": "001" &#125;&#125; req:http://localhost:8080/reference/interface/action 返回值：123&#123; "string": "this is IactionImpl method"&#125; req:http://localhost:8080/reference/interface/action2 返回值 1234&#123; "string1": "this is getString1", "string2": "this is getString1"&#125; req:http://localhost:8080/reference/array/strings 返回值： 12345["are","you","ok"] 总结： class: 是以{}作为一个对象的包装，key 是pojo 的定义的域(field), value 是注入的值。如果对象中有对象，那么就形成了json 包含 json interface: 是以{}作为一个对象的包装, 但是要注意方法的名字必须是 getXXXX, 如果其他的就会报错， key 是 定义接口方法名字getXXXX 中的XXXX ， value 是实现方法的返回值数组：是以[]作为一个对象的包装, 也对应者json 中的数组表达 collection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.ryan.restfulapi.datatype;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.*;/** * 集合类的根接口: Connection(interface)包含: 包含Set(interface)、包含List(interface)、包含Queue(interface) * &lt;p&gt; * Set(interface):HashSet、LinkedHashSet、TreesSet(SortedSet实现类) * 三种区别简述： * 同：Set 不允许有想通元素 * 异：HashSet 元素顺序有可能变化，LinkedHashSet顺序是插入时顺序， * TreeSet(SortedSet接口的唯一实现类),已经(通过自然排序和定制排序, 默认自然排序)排序 * List(interface)：ArrayList、Vector(Stack)、 LinkedList * 三种区别简述： * 同：元素有序、允许有重复的元素 * 异：Vector线程同步，ArrayList、LinkedList线程不同步 * Vector与ArrayList是通过数组实现的，LinkedList是用链表结构 * &lt;p&gt; * &lt;p&gt; * Queue(interface): LinkedList、PriorityQueue * * @author ryan **/@RestController@RequestMapping(value = "/collection")public class collection &#123; @RequestMapping(value = "/Set/HashSet") public HashSet getHashSet() &#123; HashSet&lt;String&gt; res = new HashSet&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); return res; &#125; @RequestMapping(value = "/Set/LinkedHashSet") public LinkedHashSet getLinkedHashSet() &#123; LinkedHashSet&lt;String&gt; res = new LinkedHashSet&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); return res; &#125; @RequestMapping(value = "/Set/TreeSet") public TreeSet getTreeSet() &#123; TreeSet&lt;Object&gt; res = new TreeSet&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); return res; &#125; @RequestMapping(value = "/List/ArrayList") public ArrayList getArrayList() &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); res.add("ok"); return res; &#125; @RequestMapping(value = "/List/LinkedList") public LinkedList getLinkedList() &#123; LinkedList&lt;Object&gt; res = new LinkedList&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); res.add("ok"); return res; &#125; @RequestMapping(value = "/Queue/PriorityQueue") public PriorityQueue getPriorityQueue() &#123; PriorityQueue&lt;Object&gt; res = new PriorityQueue&lt;&gt;(); res.add("are"); res.add("you"); res.add("ok"); res.add("ok"); return res; &#125;&#125; 返回数据结构： 12345678910111213141516171819202122232425262728293031323334["are","ok","you"]["are","ok","you"]["are","ok","you"]["are","you","ok","ok"]["are","you","ok","ok"]["are","ok","ok","you"] MapMap接口中键和值一一映射. 可以通过键来获取值具体访问Map官方Doc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ryan.restfulapi.datatype;import com.ryan.restfulapi.pojo.Author;import com.ryan.restfulapi.pojo.Book;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Hashtable;import java.util.LinkedHashMap;import java.util.TreeMap;/** * @author ryan * HashTable(用ConcurrentHashMap去代替)、LinkedHashMap、HashMap、TreeMap * HashTable： 别用、用ConcurrentHashMap 代替：Hashtable的实现中，大量使用了%，而不是HashMap中的位运算 * LinkedHashMap:Key和Value都允许空、有序，非线程安全 **/@RequestMapping(value = "/map")@RestControllerpublic class map &#123; @RequestMapping(value = "/Hashtable") public Hashtable getHashtable() &#123; Hashtable&lt;String, Object&gt; res = new Hashtable&lt;&gt;(); Author ryan = new Author("ryan", "001"); Book book = new Book(1, "java入门到放弃", ryan); res.put("Hashtable_key", "Hashtable_value"); res.put("book", book); return res; &#125; @RequestMapping(value = "/LinkedHashMap") public LinkedHashMap getLinkedHashMap() &#123; LinkedHashMap&lt;String, Object&gt; res = new LinkedHashMap&lt;&gt;(); Author ryan = new Author("ryan", "001"); Book book = new Book(1, "java入门到放弃", ryan); res.put("Hashtable_key", "Hashtable_value"); res.put("book", book); return res; &#125; @RequestMapping(value = "/hashmap") public HashMap getHashMap() &#123; HashMap&lt;String, Object&gt; res = new HashMap&lt;&gt;(); Author ryan = new Author("ryan", "001"); Book book = new Book(1, "java入门到放弃", ryan); res.put("Hashtable_key", "Hashtable_value"); res.put("book", book); return res; &#125; @RequestMapping(value = "/treemap") public TreeMap getTreeMap() &#123; TreeMap&lt;String, Object&gt; res = new TreeMap&lt;&gt;(); Author ryan = new Author("ryan", "001"); Book book = new Book(1, "java入门到放弃", ryan); res.put("Hashtable_key", "Hashtable_value"); res.put("book", book); return res; &#125;&#125; 返回分别为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; "book": &#123; "id": 1, "bookname": "java入门到放弃", "author": &#123; "name": "ryan", "id": "001" &#125; &#125;, "Hashtable_key": "Hashtable_value"&#125;&#123; "Hashtable_key": "Hashtable_value", "book": &#123; "id": 1, "bookname": "java入门到放弃", "author": &#123; "name": "ryan", "id": "001" &#125; &#125;&#125;&#123; "book": &#123; "id": 1, "bookname": "java入门到放弃", "author": &#123; "name": "ryan", "id": "001" &#125; &#125;, "Hashtable_key": "Hashtable_value"&#125;&#123; "Hashtable_key": "Hashtable_value", "book": &#123; "id": 1, "bookname": "java入门到放弃", "author": &#123; "name": "ryan", "id": "001" &#125; &#125;&#125; 总结 数据类型 结构 基本数据类型((byte, short,char, int, long, float, double, boolean)) 单个值 引用数据类型((class) 接口(interface)) {} 封装，key 是 结构field, value 是对应的值 引用数据类型(数组(array)) [] 封装, 值是数据结构中的值 collection(Set、List、Queue的实现类) [] 封装, 值是数据结构中的值 map(map的实现类) {} 封装，key 是 map 对应的key, value 是map对应的value 几个开发者常用封装对于restful 接口的封装，常用的就是HashMap或者是类中包含其他的类。同时为了简单调用往往采用静态方法。 状态码1234567891011121314151617181920212223public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), INADEQUATE_PERMISSIONS(104, "INADEQUATE_PERMISSIONS"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; 数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import java.io.Serializable;@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)public class ResponseResult&lt;T&gt; implements Serializable &#123; private int status; private String msg; private T data; private ResponseResult(int status)&#123; this.status = status; &#125; private ResponseResult(int status,T data)&#123; this.status = status; this.data = data; &#125; private ResponseResult(int status,String msg,T data)&#123; this.status = status; this.msg = msg; this.data = data; &#125; private ResponseResult(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; @JsonIgnore // 使之不在json序列化结果当中 public boolean isSuccess()&#123; return this.status == ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public T getData()&#123; return data; &#125; public String getMsg()&#123; return msg; &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createBySuccess()&#123; return new ResponseResult&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ResponseResult&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createBySuccess(T data)&#123; return new ResponseResult&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ResponseResult&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg,data); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createByError()&#123; return new ResponseResult&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ResponseResult&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ResponseResult&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ResponseResult&lt;T&gt;(errorCode,errorMessage); &#125; @Override public String toString() &#123; return "ResponseResult&#123;" + "status=" + status + ", msg='" + msg + '\'' + ", data=" + data + '&#125;'; &#125;&#125; 多层数据结构1234567891011121314151617181920212223public class ResponseResultMap&#123; public static ResponseResult&lt;HashMap&lt;String, Object&gt;&gt; createByList(Object value) &#123; HashMap&lt;String, Object&gt; res = new HashMap&lt;&gt;(1); res.put("list", value); return ResponseResult.createBySuccess(res); &#125; public static ResponseResult&lt;HashMap&lt;String, Object&gt;&gt; createByKV(String key, Object value) &#123; HashMap&lt;String, Object&gt; res = new HashMap&lt;&gt;(1); res.put(key, value); return ResponseResult.createBySuccess(res); &#125; public static ResponseResult createByHashMap(HashMap&lt;String, Object&gt; hashMap) &#123; HashMap&lt;String, Object&gt; res = new HashMap&lt;String, Object&gt;(3); res.putAll(hashMap); return ResponseResult.createBySuccess(res); &#125;&#125; 制表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * echart 返回的制表类型 * * @author ryan create on 2018/3/26 **/@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)public class EchartVO implements Serializable &#123; private List&lt;String&gt; legend; private List&lt;String&gt; xAxis; private List&lt;String&gt; yAxis; public EchartVO(List&lt;String&gt; legend, List&lt;String&gt; xAxis, List&lt;String&gt; yAxis) &#123; this.legend = legend; this.xAxis = xAxis; this.yAxis = yAxis; &#125; @Override public String toString() &#123; return &quot;EchartVO&#123;&quot; + &quot;legend=&quot; + legend + &quot;, xAxis=&quot; + xAxis + &quot;, yAxis=&quot; + yAxis + &apos;&#125;&apos;; &#125; public static EchartVOBuilder builder()&#123; return new EchartVOBuilder(); &#125; public static class EchartVOBuilder&#123; private List&lt;String&gt; legend; private List&lt;String&gt; xAxis; private List&lt;String&gt; yAxis; public EchartVOBuilder() &#123; &#125; public EchartVOBuilder legend(String leg) &#123; if (this.legend == null) &#123; this.legend = new ArrayList&lt;String&gt;(); &#125; this.legend.add(leg); return this; &#125; public EchartVOBuilder legend(Collection&lt;? extends String&gt; legs) &#123; if (this.legend == null) &#123; this.legend = new ArrayList&lt;&gt;(); &#125; this.legend.addAll(legs); return this; &#125; public EchartVOBuilder xAxis(String x) &#123; if (this.xAxis == null) &#123; this.xAxis = new ArrayList&lt;String&gt;(); &#125; this.xAxis.add(x); return this; &#125; public EchartVOBuilder xAxis(Collection&lt;? extends String&gt; xs) &#123; if (this.xAxis == null) &#123; this.xAxis = new ArrayList&lt;&gt;(); &#125; this.xAxis.addAll(xs); return this; &#125; public EchartVOBuilder yAxis(String y) &#123; if (this.yAxis == null) &#123; this.yAxis = new ArrayList&lt;String&gt;(); &#125; this.yAxis.add(y); return this; &#125; public EchartVOBuilder yAxis(Collection&lt;? extends String&gt; ys) &#123; if (this.yAxis == null) &#123; this.yAxis = new ArrayList&lt;&gt;(); &#125; this.yAxis.addAll(ys); return this; &#125; public EchartVO build() &#123; return new EchartVO(legend, xAxis, yAxis); &#125; @Override public String toString() &#123; return &quot;EchartVO.EchartVOBuilder&#123;&quot; + &quot;legend=&quot; + legend + &quot;, xAxis=&quot; + xAxis + &quot;, yAxis=&quot; + yAxis + &apos;&#125;&apos;; &#125; &#125;&#125;]]></content>
      <categories>
        <category>-java</category>
      </categories>
      <tags>
        <tag>-浅析Java Restful API的数据结构构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git协作加强]]></title>
    <url>%2F2018%2F01%2F21%2Fgit%E5%8D%8F%E4%BD%9C%E5%8A%A0%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[Git 协作加强名词解释 workspace: 你当前输入命令的工作区间 Repository: 你项目的的本地仓库(就是在你项目的.git 文件下) Remote: 远程仓库(如：你的gitlab 或者github中的项目) Index / Stage：暂存区 开发问题本地工程与远程仓库联系建立1git remote add origin git@github.com/名字/仓库.git 一般我们和远程仓库建立联系都是上面代码, 意思如下： 在当前的分支[master]，分割语气增加一个本源[origin] 和远程仓库[git@github.com/名字/仓库.git] 之间联系。之后我们会利用 1git push -u origin master 这个origin 是标识你所克隆的原始仓库, 你可以用其他名字, 一个项目可以有多个针对本源起的名字,同时和远程仓库一一对应，但是git clone 下来项目，默认的名字是origin . 跟进你fork的项目你会在对别人的项目https://github.com/username/projectname.git fork 到你的分支https://github.com/yourname/projectname.git 1、克隆你想要克隆的项目 1git clone https://github.com/yourname/projectname.git 这一刻你在本地会有一个origin 对应这个远程仓库,你修改代码之后可以直接push 到你的仓库1git push -u origin master 2、 和fork项目建立联系 12345git remote add username https://github.com/username/projectname.gitgit fetch username git merge username/master 3、自己代码完善的时候，可以对你fork想要发送合并请求 回到某个commit当我们读源码或者发现想回到 某个commit时 查看历史记录,获得commit 信息(commit_id)1git log 之后可行操作：12345$ git reset --hard HEAD^ 回退到上个版本$ git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前$ git reset --hard commit_id 退到/进到 指定commit的sha码 或者具体的某一个分支 1git reflog [分支名字，默认全部] 之后 git reset –hard master@{id} 比如： 1git reset --hard master@&#123;1&#125; 回到增加war包部署这一个commit 什么是冲突冲突的是因为在合并的时候，不同分支修改了相同的位置。 在gitlab/github的页面操作： 当发生冲突的时候，合并者可以看到哪些合并有冲突，然后可以手动去修改。 终端命令 在master 分支 下 合并 dev 分支 git merge dev 会在终端提示发生了冲突然后找到那个冲突 gt status 之后手动去修改12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADmaster 分支下和dev 冲突的内容=======dev 分支下和master 冲突的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev 改完之后 git add .git commit -m “conflict fixed for master merge dev” git merge 和 git rebasegit rebase 和 git merge 都是合并，但是 git rebase 更适合于 在dev 开发的人把master 合并到 dev, 及时和master跟上，git merger 适合在master 下合并 dev. 其中提交的时间顺序假设为：C1、C2、C5、C3、C6、C4、C7 你在myworkics 分支下 1git rebase master 得到的 commit 是： C7、C6、C5、C4、C3、C2、C1 1git merge master 得到的 commit 是： C7、C4、C6、C3、C5、C2、C1 tips:git rebase 会把当前分支的commit 放在最顶层 git pull 和 git fetchgit pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并 git pull是git fetch后跟git merge FETCH_HEAD的缩写 git pull origin next # 取回origin主机的next分支，与本地的当前分支合并 git pull origin next等同于 git fetch origin git merge origin/next 常用命令配置密钥 ssh-keygen -t rsa –C “邮箱” 之后复制 ~/.ssh/id_rsa 下信息到github/gitlab 的ssh key ssh -T git@github.com/git@{gitlab私建仓库地址} 配置信息 git config –global user.name “John Doe” git config –global user.email johndoe@example.com git config –global core.editor emacs ## git 终端编辑器改为emacs git config –global merge.tool vimdiff ## git 差异分析工具用vimdiff git config –list ## 查询git 信息 git help config ##获取帮助信息 配置别名 git config –global alias.st status # git status 别名为 git st 仓库建立 git init #初始化 git status #获取状态 git add [file1] [file2] … # .或*代表全部添加或者-A git commit -m “message” #将内容提交,在冒号里面最好填写英文注释 git remote add origin git@github.com/名字/ 仓库 ##此时本地工程与远程仓库已经建立了联系 仓库操作 git clone https://github.com/username/projectname.git #把远程项目克隆到本地 git add -A #跟踪新文件 git add -u [path] # 添加[指定路径下]已跟踪文件 rm &amp;git rm # 移除文件 git rm -f * # 移除文件 git rm –cached * # 停止追踪指定文件，但该文件会保留在工作区 git mv filefrom fileto # 重命名跟踪文件 git log # 查看自己提交的历史 git commit # 提交更新 git commit [file1] [file2] … # 提交指定文件 git commit -a #跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交 git commit –amend #修改最后一次提交 git commit -v #提交时显示所有diff信息 git reset HEAD *#取消已经暂存的文件 git reset –soft HEAD * #重置到指定状态，不会修改索引区和工作树 git reset –hard HEAD * #重置到指定状态，会修改索引区和工作树 git reset – files #重置index区文件 git reset –hard 11d881aea55e844dc0ebf0f3e5bf12a3ca999001 # 还原指定的提交之前的状态 git revert HEAD~ #还原前前一次操作 git checkout – file #取消对文件的修改（从暂存区——覆盖worktree file） git checkout branch | tag|commit – file_name#从仓库取出file覆盖当前分支 git checkout – .#从暂存区取出文件覆盖工作区 git diff file #查看指定文件的差异 git diff –stat #查看简单的diff结果 git diff #比较Worktree和Index之间的差异 git diff –cached #比较Index和HEAD之间的差异 git diff HEAD #比较Worktree和HEAD之间的差异 git diff branch #比较Worktree和branch之间的差异 git diff branch1 branch2 #比较两次分支之间的差异 git diff commit commit #比较两次提交之间的差异 查看日志 git log –pretty=oneline #单行显示提交日志 git log –graph # 图形化显示 git log –abbrev-commit # 显示log id的缩写 git log -num #显示第几条log（倒数） git log –stat # 显示commit历史，以及每次commit发生变更的文件 git log –follow [file] # 显示某个文件的版本历史，包括文件改名 git log -p [file] # 显示指定文件相关的每一次diff git stash #将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。 git stash list #查看保存的工作现场 git stash apply #恢复工作现场 git stash drop #删除stash内容 git stash pop #恢复的同时直接删除stash内容 git stash apply stash@{0} #恢复指定的工作现场，当你保存了不只一份工作现场时。 更新–git fetch git fetch origin # 更新远程跟踪分支(origin标记远程仓库) git fetch https://github.com/name/project.git master ##同时无需在本地存储库中配置远程，master 是远程仓库分支名 git fetch origin master # 同上(origin标记远程仓库) 更新–git pullgit pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并 git pull是git fetch后跟git merge FETCH_HEAD的缩写 git pull origin next:master # 取回origin主机的next分支，与本地的master分支合并 git pull origin next # 取回origin主机的next分支，与本地的当前分支合并 git pull origin next等同于 git fetch origin git merge origin/next 创建分支 git branch -b test #创建并切换test分支 git branch #列出本地分支 git branch -r #列出远端分支 git branch -a #列出所有分支 git branch -v #查看各个分支最后一个提交对象的信息 git branch –merge #查看已经合并到当前分支的分支 git branch –no-merge #查看为合并到当前分支的分支 git branch branch [branch|commit|tag] # 从指定位置出新建分支 git branch –track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系 git branch -m old new #重命名分支 git branch -d test #删除test分支 git branch -D test #强制删除test分支 git branch –set-upstream dev origin/dev #将本地dev分支与远程dev分支之间建立链接 git checkout test #切换到test分支 git checkout -b test dev#基于dev新建test分支，并切换 git merge test#将test分支合并到当前分支 git merge –squash test # 合并压缩，将test上的commit压缩为一条 git cherry-pick commit #拣选合并，将commit合并到当前分支 git cherry-pick -n commit #拣选多个提交，合并完后可以继续拣选下一个提交‘’ 合并分支–git rebase git rebase master #将master分之上超前的提交，变基到当前分支 git rebase –onto master 119a6 #限制回滚范围，rebase当前分支从119a6以后的提交 git rebase –interactive #交互模式 git rebase –continue# 处理完冲突继续合并 git rebase –skip# 跳过 git rebase –abort# 取消合并 合并分支–git merge git merge origin/branch#合并远端上指定分支 标签 git tag git tag #列出现有标签 git tag -a v0.1 -m ‘my version’ #新建带注释标签 git checkout tagname #切换到标签 git push origin v1.5 #推送分支到远程仓库上 git push origin –tags #一次性推送所有分支 git tag -d v0.1 #删除标签 git push origin :refs/tags/v0.1 #删除远程标签 git push origin #推送标签到远程仓库 git push origin :refs/tags/ #删除远程标签需要先删除本地标签 git checkout # 放弃工作区的修改 git reflog #显示本地执行过git命令 git remote set-url origin #修改远程仓库的url git whatchanged –since=’2 weeks ago’ #查看两个星期内的改动 git ls-files –others -i –exclude-standard #展示所有忽略的文件 git clean -X -f #清除gitignore文件中记录的文件 git status –ignored #展示忽略的文件 远程仓库的操作 git fetch origin remotebranch[:localbranch] #从远端拉去分支[到本地指定分支] git pull origin remotebranch:localbranch #拉去远端分支到本地分支 git push origin branch #将当前分支，推送到远端上指定分支 git push origin remote branch # 删除远端指定分支 git push origin remote branch –delete # 删除远程分支 git branch -dr branch # 删除本地和远程分支 git checkout -b [–track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪] 参考：https://git-scm.com/docshttps://git-scm.com/book/zh/v2]]></content>
      <categories>
        <category>-日常开发</category>
      </categories>
      <tags>
        <tag>-git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session开发使用总结]]></title>
    <url>%2F2018%2F01%2F20%2FSession%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Session开发使用总结官方网站：https://github.com/spring-projects/spring-sessionSession是一个抽象概念，开发者为了实现中断和继续操作，将user agent 和server 之间一对一的交互，抽象会“会话”，进而衍生出“会话状态”，也就是 session 的概念。Cookie是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现客户会话状态：客户每次请求时都把所有的会话数据传给服务器，服务器在每次响应时把所有的会话状态传给客户，这样的服务器可以时无状态的。使用HTML时，数据传输的时候有三种方法：URL参数、表单的隐藏和Cookie.在客户端中Cookie是可以被用户给关闭的，如果关闭了，那么就不可以支持Cookie,所以可以采用URL重写的方式。 Session 和 Cookie 在Java中的表现 Session 和 Cookie 的小实验Session的servlet:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ryan.session;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.io.PrintWriter;/** * Created by ryan */public class SessionExample extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/plain;charset=UTF-8"); HttpSession session = req.getSession(); if (session.isNew())&#123; session.setAttribute("name", "ryan"); session.setAttribute("site", "localhost.com"); &#125; String id = session.getId(); PrintWriter out = resp.getWriter(); // 如果HttpSession是新建的话 if (session.isNew()) &#123; out.println("Hello,HttpSession! The first response - SessionId=" + id + "\n"); out.println("The first-response - name: " + session.getAttribute("name")+"-CreationTime:"+session.getCreationTime() +"\n-LastAccessedTime:"+session.getLastAccessedTime() +"\n-getAttributeNames:"+session.getAttributeNames() +"\n-getServletContext:"+session.getServletContext() ); &#125; else &#123; out.println("Hello,HttpSession! The second response - SessionId=" + id + "\n"); out.println("The second-response - name: " + session.getAttribute("name")+"-CreationTime:"+session.getCreationTime() +"\n-LastAccessedTime:"+session.getLastAccessedTime() +"\n-getAttributeNames:"+session.getAttributeNames() +"\n-getServletContext:"+session.getServletContext() ); &#125; &#125;&#125; Cookie的servlet:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.ryan.cookie;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by ryan */public class CookieExample extends HttpServlet &#123; @Override protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException &#123; response.setContentType("text/plain;charset=UTF-8"); Cookie[] cookies = request.getCookies(); //get PrintWriter pw = response.getWriter(); StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append("==========================cookies length："+cookies.length+"================\n"); stringBuffer.append("===============浏览器可以传到服务端cookies变量"+"================\n"); for (Cookie cookie : cookies) &#123; stringBuffer.append("cookie.clone()----------:"+cookie.clone()+"\n"); stringBuffer.append("cookie.getComment()----------:"+cookie.getComment()+"\n"); stringBuffer.append("cookie.getDomain()----------:"+cookie.getDomain()+"\n"); stringBuffer.append("cookie.getMaxAge()----------:"+cookie.getMaxAge()+"\n"); stringBuffer.append("cookie.getName()----------:"+cookie.getName()+"\n"); stringBuffer.append("cookie.getPath()----------:"+cookie.getPath()+"\n"); stringBuffer.append("cookie.getSecure()----------:"+cookie.getSecure()+"\n"); stringBuffer.append("cookie.getValue()----------:"+cookie.getValue()+"\n"); stringBuffer.append("cookie.getVersion()----------:"+cookie.getVersion()+"\n"); stringBuffer.append("cookie.isHttpOnly()----------:"+cookie.isHttpOnly()+"\n"); &#125; // 创建Cookie Cookie cookie = new Cookie("CookieName", "CookieValue"); cookie.setComment("this is set comment");// cookie.setDomain("localhost.com");// cookie.setPath("/cookie/path");// cookie.setSecure(true); //cookie.setValue("this is set value"); Assigns a new value to a cookie after the cookie is created. cookie.setMaxAge(10); cookie.setHttpOnly(true); response.addCookie(cookie); pw.write(String.valueOf(stringBuffer)); &#125;&#125; 配置的web.xml123456789101112131415161718192021&lt;!--This is Cookie example--&gt; &lt;servlet&gt; &lt;servlet-name&gt;CookieExample&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ryan.cookie.CookieExample&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CookieExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/CookieExample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--This is Cookie example--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SessionExample&lt;/servlet-name&gt; &lt;servlet-class&gt;com.ryan.session.SessionExample&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SessionExample&lt;/servlet-name&gt; &lt;url-pattern&gt;/SessionExample&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 启动访问结果： Cookie 和 Session 的域对于上面的小试验，我们可以看出http://localhost:8060/CookieExample和http://localhost:8060/SessionExample两个请求的URL得到的唯一标识符是相同的(两个请求都是在同一浏览器中请求，在不同的浏览器中就不一样)。可以把这两个url规定为同一个源(origin).或者同域。如果不同域，那么就存在跨域这么一说。单从请求的URL来说，没有跨域那么Cookie就是同一个, 服务器存储的也就对应一个 域是通过“URL的首部”来识别, “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。 也就是说，下面三种类型的URL是三个不同的域，浏览器也就会对应三个域，保存三个Cookie http://192.168.1.214:19999/*http://192.168.1.214:80/*https://192.168.1.214:19999/* Session 和Cookie生产机制刚刚我们知道浏览器在第一次访问服务器时, 服务器此刻就会和你请求的客户端形成session(会话)，同时在服务端会对应生成一个sessionid.同时把服务端生成的数据(在header中)发送给请求端(浏览器)，此刻请求端根据域来存储这个域对应的Cookie。下面是chrome中的信息(注：tomcat生成的sessionid叫做jsessionid)： SessionID 是怎么产生的我们先来看看SessionID是怎么生产的(是直接github上最新版的源码，之前版本有点区别)，首先进入tomcat在github的源码中查看ManagerBase源码中123456789101112131415161718protected String generateSessionId() &#123; String result = null; do &#123; if (result != null) &#123; // Not thread-safe but if one of multiple increments is lost // that is not a big deal since the fact that there was any // duplicate is a much bigger issue. duplicates++; &#125; result = sessionIdGenerator.generateSessionId(); &#125; while (sessions.containsKey(result)); return result;&#125; 结果是：result = sessionIdGenerator.generateSessionId(); 生成的，之后再看generateSessionId：1234@Overridepublic String generateSessionId() &#123; return generateSessionId(jvmRoute);&#125; 其中jvmRoute：12/** Node identifier when in a cluster. Defaults to the empty string. */private String jvmRoute = ""; 之后再看generateSessionId：123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic String generateSessionId(String route) &#123; byte random[] = new byte[16]; int sessionIdLength = getSessionIdLength(); // Render the result as a String of hexadecimal digits // Start with enough space for sessionIdLength and medium route size StringBuilder buffer = new StringBuilder(2 * sessionIdLength + 20); int resultLenBytes = 0; while (resultLenBytes &lt; sessionIdLength) &#123; getRandomBytes(random); for (int j = 0; j &lt; random.length &amp;&amp; resultLenBytes &lt; sessionIdLength; j++) &#123; byte b1 = (byte) ((random[j] &amp; 0xf0) &gt;&gt; 4); byte b2 = (byte) (random[j] &amp; 0x0f); if (b1 &lt; 10) buffer.append((char) ('0' + b1)); else buffer.append((char) ('A' + (b1 - 10))); if (b2 &lt; 10) buffer.append((char) ('0' + b2)); else buffer.append((char) ('A' + (b2 - 10))); resultLenBytes++; &#125; &#125; if (route != null &amp;&amp; route.length() &gt; 0) &#123; buffer.append('.').append(route); &#125; else &#123; String jvmRoute = getJvmRoute(); if (jvmRoute != null &amp;&amp; jvmRoute.length() &gt; 0) &#123; buffer.append('.').append(jvmRoute); &#125; &#125; return buffer.toString();&#125; 因为我再实验的是用的是tomcat8所以在生成SessionID的时候有点不一样，下面是sessionID的生产的方式：12345678910111213141516171819202122232425262728293031323334public String generateSessionId() &#123; byte random[] = new byte[16]; // Render the result as a String of hexadecimal digits StringBuilder buffer = new StringBuilder(); int resultLenBytes = 0; while (resultLenBytes &lt; sessionIdLength) &#123; getRandomBytes(random); for (int j = 0; j &lt; random.length &amp;&amp; resultLenBytes &lt; sessionIdLength; j++) &#123; byte b1 = (byte) ((random[j] &amp; 0xf0) &gt;&gt; 4); byte b2 = (byte) (random[j] &amp; 0x0f); if (b1 &lt; 10) buffer.append((char) ('0' + b1)); else buffer.append((char) ('A' + (b1 - 10))); if (b2 &lt; 10) buffer.append((char) ('0' + b2)); else buffer.append((char) ('A' + (b2 - 10))); resultLenBytes++; &#125; &#125; if (jvmRoute != null &amp;&amp; jvmRoute.length() &gt; 0) &#123; buffer.append('.').append(jvmRoute); &#125; return buffer.toString();&#125; 我们可以产生如下总结： sessionid产生方法：随机数+时间+jvm路径其中时间是在getRandomBytes产生随机数的时候加入的 对于SessionId的生命周期篇幅就有点大了，下次陈述 前后分离中的Cookie 和Session对于前后分离，因为前后分开部署，所以最起码端口号是不一样的。所以会出现了跨域。这就需要通过跨域资源共享来实现session的共享。下面来简述如何实现跨域共享,同时请求和回应的参数如下： 前端传递参数前端在发送请求的时候，需要设置：Access-Control-Allow-Credentials: true.目的是跨域的时候，让浏览器发送Cookie 到服务器(CORS请求默认是不发送Cookie和HTTP认证信息), 如下就是一个jq发送ajax请求时，带上需要的参数1234567891011121314$.ajax(&#123; type: "POST", url: "post_url", dataType: 'json', data: &#123; id: 100 &#125;, xhrFields: &#123; withCredentials: true &#125;, success: function(data) &#123; console.log("返回的数据: " + data); &#125;&#125;); 后端设置参数后端设置设置参数也就是服务器回应的其他CORS相关字段.Request headers Origin // 跨域请求的地址 Access-Control-Request-Method // 请求方法 Access-Control-Request-Headers // Headers Response headers Access-Control-Allow-Origin // 允许返回的域名 Access-Control-Allow-Credentials Access-Control-Expose-Headers // 列出了哪些首部可以作为响应的一部分暴露给外部。 Access-Control-Max-Age // 可以被缓存多久(单位秒) Access-Control-Allow-Methods Access-Control-Allow-Headers 上面字段具体含义可以参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers 所以服务器端对于需要跨域资源共享的请求，要做一些上面的处理。下面贴出两种常用的方式。 方式1:Spring框架提供的跨域CorsConfiguration1234567891011121314151617181920212223import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfig &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); // 1 corsConfiguration.addAllowedHeader("*"); // 2 corsConfiguration.addAllowedMethod("*"); // 3 return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); // 4 return new CorsFilter(source); &#125;&#125; 方式2:filter层进行请求拦截123456789101112131415161718192021222324252627282930313233343536import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * 解决跨域问题 * * @author ryan **/@Componentpublic class CORSFilter implements Filter &#123; @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) res; HttpServletRequest reqs = (HttpServletRequest) req; response.setHeader("Access-Control-Allow-Origin",reqs.getHeader("Origin")); response.setHeader("Access-Control-Allow-Credentials", "true"); response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "x-requested-with"); chain.doFilter(req, res); &#125; @Override public void init(FilterConfig filterConfig) &#123;&#125; @Override public void destroy() &#123;&#125;&#125; ##http://blog.csdn.net/patrickyoung6625/article/details/45694157]]></content>
      <categories>
        <category>-日常开发</category>
      </categories>
      <tags>
        <tag>-session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Go Web Examples》中文翻译]]></title>
    <url>%2F2017%2F10%2F22%2FGoWebExamples%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[本文是GO中国社区发起翻译的文章，由本人翻译。github项目地址访问这里.原英文访问这里 Hello WorldIntroductionGo 是一个自带干粮的编程语言，拥有自己的内置webserver.标准库中的net/http 包包含了关于HTTP协议的全部功能的函数。包中包含了一个HTTP client和 一个HTTP server . 在本例子中你将会发现成功创建一个你可以在浏览器中浏览网页的webserver是有多么简单。 Registering a Request Handle首先，创建一个从浏览器接受进来的HTTP链接、HTTP client 或者API请求的Handler， 在Go 中是一个函数，它在创建的时候，形态上有如下相似特点1func (w http.ResponseWriter, r *http.Request) 这个函数接受两个参数： http.ResponseWriter: 这个参数是给你写你的text/html响应的http.Request : 它包含所有HTTP请求的信息，比如URL 或者 header注册一个的HTTP Server 的request handler 非常简单，如下就是：123http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "Hello, you've requested: %s\n", r.URL.Path)&#125;) Listen for HTTP Connections一个单独的request handler不能接受任何外部的HTTP 链接。一个HTTP Server,为了把链接发送给request handle， 它必须监听一个端口。由于80端口是大多数默认的HTTP 流量通道， 所以本server也会用80端口来监控。下面的代码会启动一个GO的默认HTTP server ,同时监听80端口上的链接。你可以在你的浏览器中访问http://localhost/, 同时可以看到你的server正在处理你的request:1http.ListenAndServe(":80", nil) The Code (for copy/paste)下面是完整的代码1234567891011121314package mainimport ( "fmt" "net/http")func main() &#123; http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, "Hello, you've requested: %s\n", r.URL.Path) &#125;) http.ListenAndServe(":80", nil)&#125; Routing (using gorilla/mux)introductionGo 的net/http 包提供了许多HTTP协议功能的函数。有一件事件，它还做的不够好，比如对于复杂的请求路由把请求的url分割成单个参数。幸运的是，在Go的社区里，有一个非常流行的package 来解决这个问题。在本例中，你将会看到如何用 gorilla/mux以命名参数、GET/POST Hander 和域名限制的形式来创建路由 Installing the gorilla/mux packagegorilla/mux 在写web 应用时，它带来了许多特性来提升生产效率。它在创建的时候，形态上和GO原始创建request handler 在创建形式上相似:func (w http.ResponseWriter, r *http.Request).所以这个包可以和其他HTTP 库混合使用，比如middleware 或已经存在的应用。通过 go get从 Github 上下载安装： go get -u github.com/gorilla/mux Creating a new Router首先创建一个新的路由。对于你的web应用，这个路由是主路由，它会传递参数到你的server.它会接受所有的HTTP链接，同时发送到你注册的request handler 上。你可以像下面一下创建：1r := mux.NewRouter() Registering a Request Handler当你已经创建了一个路由，你可以像内置包那样注册request handler.唯一不同的是，调用 http.HandleFunc(...)时，你可以用r.HandleFunc(...) 来代替 URL Parametersgorilla/mux 路由最具有能量的地方是从请求的URL上提取信息。作为一个例子，比如下面是你应用的URL:1/books/go-programming-blueprint/page/10 这个URL有两个动态部分：121.Book 的标题（go-programming-blueprint）2.页数(10) 对于上面提到的URL,在处理request handler时， 你可以如下处理，来做动态参数处理：1234r.HandleFunc("/books/&#123;title&#125;/page/&#123;page&#125;", func(w http.ResponseWriter, r *http.Request) &#123; // get the book // navigate to the page&#125;) 最后一件事就是从动态参数中获取数据。这个包提供一个函数mux.Vars(r) ,它把http.Request作为一个参数，并把动态参数以map的形式返回 12345func(w http.ResponseWriter, r *http.Request) &#123; vars := mux.Vars(r) vars["title"] // the book title slug vars["page"] // the page&#125; Setting the HTTP server’s router想知道nil 在http.ListenAndServe(&quot;:80&quot;, nil) 的意义？它是HTTP server d的主路由的参数。默认情况下，它是nil， 它表示用net/http包的默认路由。 为了利用你自己的路由，用你的路由参数r 取代 nil1http.ListenAndServe(&quot;:80&quot;, r) The Code (for copy/paste)下面是全部的代码123456789101112131415161718192021package mainimport ( "fmt" "net/http" "github.com/gorilla/mux")func main() &#123; r := mux.NewRouter() r.HandleFunc("/books/&#123;title&#125;/page/&#123;page&#125;", func(w http.ResponseWriter, r *http.Request) &#123; vars := mux.Vars(r) title := vars["title"] page := vars["page"] fmt.Fprintf(w, "You've requested the book: %s on page %s\n", title, page) &#125;) http.ListenAndServe(":80", r)&#125; Features of the gorilla/mux RouterMethods将请求方法指定为HTTP 方法1234r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, CreateBook).Methods(&quot;POST&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, ReadBook).Methods(&quot;GET&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, UpdateBook).Methods(&quot;PUT&quot;)r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, DeleteBook).Methods(&quot;DELETE&quot;) Hostnames &amp; Subdomains对特定的hostname或子域名做限制 1r.HandleFunc(&quot;/books/&#123;title&#125;&quot;, BookHandler).Host(&quot;www.mybookstore.com&quot;) Schemes将请求限制为http/https12r.HandleFunc(&quot;/secure&quot;, SecureHandler).Schemes(&quot;https&quot;)r.HandleFunc(&quot;/insecure&quot;, InsecureHandler).Schemes(&quot;http&quot;) Path Prefixes &amp; Subrouters将请求限定为特定的路径123bookrouter := r.PathPrefix(&quot;/books&quot;).Subrouter()bookrouter.HandleFunc(&quot;/&quot;, AllBooks)bookrouter.HandleFunc(&quot;/&#123;title&#125;&quot;, GetBook) TemplatesIntroductionGo 的html/template包对HTML模板提供了丰富的模板语言。它主要用于Web应用程序，在客户端的浏览中以结构化的方式显示数据。Go 模板语言最大的好处就是数据的自动转义。没有必要担心在显示浏览器之前，那些作为GO解析HTML模板的XSS攻击和避开所有输入。 First TemplateGO写一个模板非常简单。这个例子展示一个TODO 列表, 用HTML中的无序列表 （ul）来写， 当渲染模板时， 可以从GO的各种数据结构中导入。它可以是简单的string 或 数字， 它甚至可以是嵌套的数据结构。要访问模板中的数据，最前的变量是通过&#123;&#123; &#125;&#125; 来访问。其中 花括号中的点(.) 称为管道和root12345678data := TodoPageData&#123; PageTitle: "My TODO list", Todos: []Todo&#123; &#123;Title: "Task 1", Done: false&#125;, &#123;Title: "Task 2", Done: true&#125;, &#123;Title: "Task 3", Done: true&#125;, &#125;,&#125; 12345678910&lt;h1&gt;&#123;&#123;.PageTitle&#125;&#125;&lt;h1&gt;&lt;ul&gt; &#123;&#123;range .Todos&#125;&#125; &#123;&#123;if .Done&#125;&#125; &lt;li class="done"&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;li&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;end&#125;&#125; &#123;&#123;end&#125;&#125;&lt;/ul&gt; Control Structures模板语言包含一组丰富的控制结构来渲染HTML.这里你将会看到一些最常用的。更详细的清单访问text/template|Control Structure | Definition|—|—|&#123;&#123;/ a comment /&#125;&#125; | Defines a comment||&#123;&#123;.&#125;&#125; | Renders the root element||&#123;&#123;.Title&#125;&#125; | Renders the “Title”-field in a nested element||&#123;&#123;if .Done&#125;&#125; &#123;&#123;else&#125;&#125; &#123;&#123;end&#125;&#125; | Defines an if-Statement||&#123;&#123;range .Todos&#125;&#125; &#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125; | Loops over all “Todos” and renders each using &#123;&#123;.&#125;&#125;||&#123;&#123;block “content” .&#125;&#125; &#123;&#123;end&#125;&#125; | Defines a block with the name “content”| Parsing Templates from Files模板可以是从一个字符串或者磁盘上的文件解析。通常下，模板是来自磁盘。这个example 展示了如何来操作。在这个例子，下面GO程序中，有一个模板名字为layout.html123tmpl, err := template.ParseFiles("layout.html")// ortmpl := template.Must(template.ParseFiles("layout.html")) Execute a Template in a Request Handler模板从磁盘解析后，就可以在请求处理程序中使用它。Execute 函数接受一个写入模板的io.Writer和一个将数据传递到模板中的 interface {} 。当被一个http.ResponseWriter 调用时. Content-Type 是被自动设置在HTTP response 中123func(w http.ResponseWriter, r *http.Request) &#123; tmpl.Execute(w, "data goes here")&#125; The Code (for copy/paste)下面是全部代码12345678910111213141516171819202122232425262728293031323334package mainimport ( "html/template" "net/http")type Todo struct &#123; Title string Done bool&#125;type TodoPageData struct &#123; PageTitle string Todos []Todo&#125;func main() &#123; tmpl := template.Must(template.ParseFiles("layout.html")) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; data := TodoPageData&#123; PageTitle: "My TODO list", Todos: []Todo&#123; &#123;Title: "Task 1", Done: false&#125;, &#123;Title: "Task 2", Done: true&#125;, &#123;Title: "Task 3", Done: true&#125;, &#125;, &#125; tmpl.Execute(w, data) &#125;) http.ListenAndServe(":80", nil)&#125; 12345678910&lt;h1&gt;&#123;&#123;.PageTitle&#125;&#125;&lt;h1&gt;&lt;ul&gt; &#123;&#123;range .Todos&#125;&#125; &#123;&#123;if .Done&#125;&#125; &lt;li class="done"&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;else&#125;&#125; &lt;li&gt;&#123;&#123;.Title&#125;&#125;&lt;/li&gt; &#123;&#123;end&#125;&#125; &#123;&#123;end&#125;&#125;&lt;/ul&gt; Forms这个例子将演示如何模拟联系人表单并将其解析为结构12345678910111213141516171819202122232425262728293031323334353637// forms.gopackage mainimport ( "html/template" "net/http")type ContactDetails struct &#123; Email string Subject string Message string&#125;func main() &#123; tmpl := template.Must(template.ParseFiles("forms.html")) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; if r.Method != http.MethodPost &#123; tmpl.Execute(w, nil) return &#125; details := ContactDetails&#123; Email: r.FormValue("email"), Subject: r.FormValue("subject"), Message: r.FormValue("message"), &#125; // do something with details _ = details tmpl.Execute(w, struct&#123; Success bool &#125;&#123;true&#125;) &#125;) http.ListenAndServe(":8080", nil)&#125; 123456789101112131415&lt;!-- forms.html --&gt;&#123;&#123;if .Success&#125;&#125; &lt;h1&gt;Thanks for your message!&lt;/h1&gt;&#123;&#123;else&#125;&#125; &lt;h1&gt;Contact&lt;/h1&gt; &lt;form method="POST"&gt; &lt;label&gt;Email:&lt;/label&gt;&lt;br /&gt; &lt;input type="text" name="email"&gt;&lt;br /&gt; &lt;label&gt;Subject:&lt;/label&gt;&lt;br /&gt; &lt;input type="text" name="subject"&gt;&lt;br /&gt; &lt;label&gt;Message:&lt;/label&gt;&lt;br /&gt; &lt;textarea name="message"&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type="submit"&gt; &lt;/form&gt;&#123;&#123;end&#125;&#125; Assets and Files这个例子将展示如何使用静态文件比如CSS、 JavaScripts或图片1234567891011// static-files.gopackage mainimport "net/http"func main() &#123; fs := http.FileServer(http.Dir("assets/")) http.Handle("/static/", http.StripPrefix("/static/", fs)) http.ListenAndServe(":8080", nil)&#125; 1234$ tree assets/assets/└── css └── styles.css 123456$ go run static-files.go$ curl -s http://localhost:8080/static/css/styles.cssbody &#123; background-color: black;&#125; Middleware (Basic)这个例子将展示如何在GO中创建基本的日志中间件。一个中间件只需要一个 http.HandlerFunc 作为它其中的一个参数，装饰它，并返回一个新的http.HandlerFunc用于服务器调用123456789101112131415161718192021222324252627282930// basic-middleware.gopackage mainimport ( "fmt" "log" "net/http")func logging(f http.HandlerFunc) http.HandlerFunc &#123; return func(w http.ResponseWriter, r *http.Request) &#123; log.Println(r.URL.Path) f(w, r) &#125;&#125;func foo(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "foo")&#125;func bar(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "bar")&#125;func main() &#123; http.HandleFunc("/foo", logging(foo)) http.HandleFunc("/bar", logging(bar)) http.ListenAndServe(":8080", nil)&#125; 12345678$ go run basic-middleware.go2017/02/10 23:59:34 /foo2017/02/10 23:59:35 /bar2017/02/10 23:59:36 /foo?bar$ curl -s http://localhost:8080/foo$ curl -s http://localhost:8080/bar$ curl -s http://localhost:8080/foo?bar Middleware (Advanced)这个例子将展示如何在GO中创建更高级的中间件。一个中间件只需要一个http.HandlerFunc 作为它的一个参数，装饰它并把它作为一个新的 http.HandlerFunc 给服务器调用 在这里，我们定义一个新的类型Middleware, 它可以更容易的链接多个中间件。这个想法灵感来自于Mat Ryer 谈论如果建立APIs.你可以从这里 查看更详细的这个片段详细展示了如何创建一个新的中间件。此处下面是完整的例子，这里我们减少了一些样板代码。123456789101112131415161718192021unc createNewMiddleware() Middleware &#123; // Create a new Middleware middleware := func(next http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc which is called by the server eventually handler := func(w http.ResponseWriter, r *http.Request) &#123; // ... do middleware things // Call the next middleware/handler in chain next(w, r) &#125; // Return newly created handler return handler &#125; // Return newly created middleware return middleware&#125; 下面是完整的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// advanced-middleware.gopackage mainimport ( "fmt" "log" "net/http" "time")type Middleware func(http.HandlerFunc) http.HandlerFunc// Logging logs all requests with its path and the time it took to processfunc Logging() Middleware &#123; // Create a new Middleware return func(f http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc return func(w http.ResponseWriter, r *http.Request) &#123; // Do middleware things start := time.Now() defer func() &#123; log.Println(r.URL.Path, time.Since(start)) &#125;() // Call the next middleware/handler in chain f(w, r) &#125; &#125;&#125;// Method ensures that url can only be requested with a specific method, else returns a 400 Bad Requestfunc Method(m string) Middleware &#123; // Create a new Middleware return func(f http.HandlerFunc) http.HandlerFunc &#123; // Define the http.HandlerFunc return func(w http.ResponseWriter, r *http.Request) &#123; // Do middleware things if r.Method != m &#123; http.Error(w, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return &#125; // Call the next middleware/handler in chain f(w, r) &#125; &#125;&#125;// Chain applies middlewares to a http.HandlerFuncfunc Chain(f http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc &#123; for _, m := range middlewares &#123; f = m(f) &#125; return f&#125;func Hello(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintln(w, "hello world")&#125;func main() &#123; http.HandleFunc("/", Chain(Hello, Method("GET"), Logging())) http.ListenAndServe(":8080", nil)&#125; 12345678$ go run advanced-middleware.go2017/02/11 00:34:53 / 0s$ curl -s http://localhost:8080/hello world$ curl -s -XPOST http://localhost:8080/Bad Request Sessions这个例子将会展示如何通过流行的gorilla/sessions包，存储session cookiescookie 是存储在用户浏览器中的小数据，并在每次请求时发送到服务器。在它们中，我们可以存储用户是否登录到我们的网站，并找出它时间上是谁（在我们系统中）在本例中，我们只允许经过身份验证在/secret 页上查看隐私的信息。要访问它，首先要访问/login得到有效的会话cookie.此外，他可以访问/logout 来注销我们访问私密信息的权限12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// sessions.gopackage mainimport ( "fmt" "net/http" "github.com/gorilla/sessions")var ( // key must be 16, 24 or 32 bytes long (AES-128, AES-192 or AES-256) key = []byte("super-secret-key") store = sessions.NewCookieStore(key))func secret(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Check if user is authenticated if auth, ok := session.Values["authenticated"].(bool); !ok || !auth &#123; http.Error(w, "Forbidden", http.StatusForbidden) return &#125; // Print secret message fmt.Fprintln(w, "The cake is a lie!")&#125;func login(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Authentication goes here // ... // Set user as authenticated session.Values["authenticated"] = true session.Save(r, w)&#125;func logout(w http.ResponseWriter, r *http.Request) &#123; session, _ := store.Get(r, "cookie-name") // Revoke users authentication session.Values["authenticated"] = false session.Save(r, w)&#125;func main() &#123; http.HandleFunc("/secret", secret) http.HandleFunc("/login", login) http.HandleFunc("/logout", logout) http.ListenAndServe(":8080", nil)&#125; 12345678910$ go run sessions.go$ curl -s http://localhost:8080/secretForbidden$ curl -s -I http://localhost:8080/loginSet-Cookie: cookie-name=MTQ4NzE5Mz...$ curl -s --cookie "cookie-name=MTQ4NzE5Mz..." http://localhost:8080/secretThe cake is a lie! JSON本例将展示如何使用encoding/json包来编码和解码 JSON文件的1234567891011121314151617181920212223242526272829303132333435// json.gopackage mainimport ( "encoding/json" "fmt" "net/http")type User struct &#123; Firstname string `json:"firstname"` Lastname string `json:"lastname"` Age int `json:"age"`&#125;func main() &#123; http.HandleFunc("/decode", func(w http.ResponseWriter, r *http.Request) &#123; var user User json.NewDecoder(r.Body).Decode(&amp;user) fmt.Fprintf(w, "%s %s is %d years old!", user.Firstname, user.Lastname, user.Age) &#125;) http.HandleFunc("/encode", func(w http.ResponseWriter, r *http.Request) &#123; peter := User&#123; Firstname: "John", Lastname: "Doe", Age: 25, &#125; json.NewEncoder(w).Encode(peter) &#125;) http.ListenAndServe(":8080", nil)&#125; 1234567$ go run json.go$ curl -s -XPOST -d'&#123;"firstname":"Donald","lastname":"Trump","age":70&#125;' http://localhost:8080/decodeDonald Trump is 70 years old!$ curl -s http://localhost:8080/encode&#123;"firstname":"John","lastname":"Doe","age":25&#125; Websockets这个例子将展示如何使用Websockets。我们将建立一个简单的server,它发回我们发给它所有的内容。这里我们用go get来下载gorilla/websocket1go get github.com/gorilla/websocket 下面是全部的代码123456789101112131415161718192021222324252627282930313233343536373839404142// websockets.gopackage mainimport ( "fmt" "net/http" "github.com/gorilla/websocket")var upgrader = websocket.Upgrader&#123; ReadBufferSize: 1024, WriteBufferSize: 1024,&#125;func main() &#123; http.HandleFunc("/echo", func(w http.ResponseWriter, r *http.Request) &#123; conn, _ := upgrader.Upgrade(w, r, nil) // error ignored for sake of simplicity for &#123; // Read message from browser msgType, msg, err := conn.ReadMessage() if err != nil &#123; return &#125; // Print the message to the console fmt.Printf("%s sent: %s\n", conn.RemoteAddr(), string(msg)) // Write message back to browser if err = conn.WriteMessage(msgType, msg); err != nil &#123; return &#125; &#125; &#125;) http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) &#123; http.ServeFile(w, r, "websockets.html") &#125;) http.ListenAndServe(":8080", nil)&#125; 12345678910111213141516171819202122&lt;!-- websockets.html --&gt;&lt;input id="input" type="text" /&gt;&lt;button onclick="send()"&gt;Send&lt;/button&gt;&lt;pre id="output"&gt;&lt;/pre&gt;&lt;script&gt; var input = document.getElementById("input"); var output = document.getElementById("output"); var socket = new WebSocket("ws://localhost:8080/echo"); socket.onopen = function () &#123; output.innerHTML += "Status: Connected\n"; &#125;; socket.onmessage = function (e) &#123; output.innerHTML += "Server: " + e.data + "\n"; &#125;; function send() &#123; socket.send(input.value); input.value = ""; &#125;&lt;/script&gt; 12$ go run websockets.go[127.0.0.1]:53403 sent: Hello Go Web Examples, you're doing great! ###Password Hashing (bcrypt)这个例子将展示如何使用bcrypt 来hash 密码，获取package:1$ go get golang.org/x/crypto/bcrypt 从现在开始，我们编写的每个应用程序都利用这个库1234567891011121314151617181920212223242526272829// passwords.gopackage mainimport ( &quot;fmt&quot; &quot;golang.org/x/crypto/bcrypt&quot;)func HashPassword(password string) (string, error) &#123; bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14) return string(bytes), err&#125;func CheckPasswordHash(password, hash string) bool &#123; err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil&#125;func main() &#123; password := &quot;secret&quot; hash, _ := HashPassword(password) // ignore error for the sake of simplicity fmt.Println(&quot;Password:&quot;, password) fmt.Println(&quot;Hash: &quot;, hash) match := CheckPasswordHash(password, hash) fmt.Println(&quot;Match: &quot;, match)&#125; 1234$ go run passwords.goPassword: secretHash: $2a$14$ajq8Q7fbtFRQvXpdCq7Jcuy.Rx1h/L4J60Otx.gyNLbAYctGMJ9tKMatch: true]]></content>
      <categories>
        <category>-翻译</category>
      </categories>
      <tags>
        <tag>-翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java和python中的Concurrent包的future异步]]></title>
    <url>%2F2017%2F09%2F17%2Fjava%E5%92%8Cpython%E4%B8%AD%E7%9A%84Concurrent%E5%8C%85%E7%9A%84future%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[本文主要阐述了java和python中concurrent包下的future异步，对于python中的concurrent.futures是在借鉴java的java.util.concurrent包的思想而成，然而python多线程中又有GIL的限制，所以下面就来看看两个语言下的concurrent下的future异同 接口的简单认识java中的future 是java.util.concurrent包下面的一个接口，该接口定义如下源码12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Python定义的是一个类源码123456789101112131415161718192021class Future(object): """Represents the result of an asynchronous computation.""" def __init__(self): self._condition = threading.Condition() self._state = PENDING self._result = None self._exception = None self._waiters = [] self._done_callbacks = [] def _invoke_callbacks(self): def __repr__(self): def cancelled(self): def running(self): def done(self): def __get_result(self): def add_done_callback(self, fn): def result(self, timeout=None): def exception(self, timeout=None): def set_running_or_notify_cancel(self): def set_result(self, result): def set_exception(self, exception): 语言特性带来的差异java在定义的时候定义的是一个接口，进行规范，在实现上比较自由，比如spring 框架的并发包：org.springframework.util.concurrent 就是继承Future这个抽象类。python定义的是一个类(虽然有abc但没用)，也就是在实现的时候，虽然可以去继承，但是为了解除冗余性，往往自己重新去实现了一下Future, 比如 asyncio.Future就是重新设计的，所以这一点来说java面向接口编程特点比Python还是要强很多，在面对各种并发问题的时候，java优势就更加明显 相同点两个语言 Future 可以从 Executor（java 是Executors）下的submit() 实例化得到， 但是java的特性，Executors提供更丰富的接口 java 的Executors接口：python的Executor接口： python 的concurrent.futures 却只有ProcessPoolExecutor和ThreadPoolExecutor， 目的也简单，前者主要解决 CPU密集问题，后者主要解决IO密集问题，因为在执行阻塞型 I/O 操作的函数， 在等待操作系统返回结果时都会释放 GIL， 所以Python中的多线程此刻才体现优势（相对于串行而言） 下面来简单的实验一下java的实现:123456789101112131415161718192021222324252627282930313233import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class demo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; final int processors = Runtime.getRuntime().availableProcessors(); final ExecutorService exec = Executors.newFixedThreadPool(processors); Callable call = new Callable()&#123; public String call() throws Exception&#123; System.out.println("Hey, Man! this is thread1!!"); Thread.sleep(1000 * 3); return "This is thread1 and result is string, you can return other object"; &#125; &#125;; Future thead1 = exec.submit(call); //主线程设置了2秒，thead1 要sleep 3秒，但是两者是同时执行的 Thread.sleep(1000 * 2); System.out.println("this is main thread "); //其他不重要的事情 String res = (String) thead1.get(); System.out.println(res); //关闭线程池 exec.shutdown(); /* 打印：*/ //Hey, Man! this is thread1!! //this is main thread //This is thread1 and result is string, you can return other object &#125;&#125; python的实现：12345678910111213141516# coding=utf-8import concurrent.futuresimport timedef task(): print("Hey, Man! this is thread1!!") return "This is thread1 and result is string, you can return other object"def learn(): with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor: time.sleep(3) thread1 = executor.submit(task) print(thread1.result())if __name__ == '__main__': learn() 同时可以通过下面的代码来比较一下python中的ProcessPoolExecutor和ThreadPoolExecutor ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# coding=utf-8import concurrent.futuresimport datetimeclass Number(object): """Number class""" def __init__(self): super(Number, self).__init__() self.futures = set() @property def one_func(self): for i in range(1, 10): yield i @property def two_func(self): for i in range(1, 10): yield i*2 @property def three_func(self): for i in range(1, 10): yield i*3 def n_func(self, n): def inner(): for i in range(1, 10): yield i*n return set(inner()) def share_value(self, n): """ 用于检测一个变量在并发中是否共享 """ def inner(): for i in range(1, 10): yield i return self.futures.update(set(inner())) # ThreadPoolExecutor def learn(self): start_time = datetime.datetime.now() with concurrent.futures. ThreadPoolExecutor(max_workers=8) as executor: tasks = [self.one_func, self.two_func, self.three_func] future_task = &#123;executor.submit(task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] for i in number: print(i) end_time = datetime.datetime.now() print(end_time - start_time) #range(1, 10): 0:00:00.001001 range(1, 100000): 0:00:01.386313 # ProceessProolExecutor def train(self): start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.n_func, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] print(number) print(future.result()) end_time = datetime.datetime.now() print(end_time-start_time) # range(1, 10):0:00:00.297790 range(1, 100000): 0:00:00.465234 # 在并发中因为开启了多个 interpreter, 所以数据是不共享的 def con_shared_value_test(self): ''' 此处用的是实例化开始的时候就加入的变量作为接受数据变量 ''' start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.share_value, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] print(number) # n print(future.result()) # None end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时： 0:00:00.308821 range(1, 100000) 耗时： 0:00:00.060158 # 多线程把数据发到一个变量 def multiThread_share_value(self): start_time = datetime.datetime.now() with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor: tasks = [self.one_func, self.two_func, self.three_func] future_task = &#123;executor.submit(task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] self.futures.update(set(number)) end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时： 0:00:00.001977 range(1, 100000) 耗时： 0:00:00.049100 # 多进程把数据发到一个变量 def multiProcess_share_value(self): start_time = datetime.datetime.now() with concurrent.futures. ProcessPoolExecutor(max_workers=8) as executor: future_task = &#123;executor.submit(self.n_func, i): i for i in range(1, 8)&#125; for future in concurrent.futures.as_completed(future_task): number = future_task[future] self.futures.update(set(future.result())) end_time = datetime.datetime.now() print("耗时：",(end_time-start_time)) # range(1, 10):耗时：耗时： 0:00:00.297792 range(1, 100000) 耗时： 0:00:00.402069if __name__ == '__main__': n = Number() n.multiProcess_share_value() print(n.futures) 需求现在我们设定一个需求, 来看看两个语言下的future解决同一个问题是怎么处理的。需求是从各大网站爬取一些免费的代理IP,因为爬取的时候。各个任务在跑的时候是不相关的，所以我们可以用异步来执行这些，现在我们决定爬取的网站如下： http://www.xicidaili.com/nn/http://www.66ip.cn/http://www.nianshao.me/ 编码实现javajava在实现任务的时候，采用的spring boot, 但还是代码量太多，于是贴出只核心部分：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import com.legotime.constant.Constants;import com.legotime.domain.ProxyIP;import com.legotime.util.ProxyUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import java.util.*;import java.util.concurrent.*;/*** 从网络爬取代理IP*/@Configurationpublic class FreeProxy &#123; private static final Logger log = LoggerFactory.getLogger(FreeProxy.class); public HashSet&lt;ProxyIP&gt; ipSet = new HashSet&lt;ProxyIP&gt;(); public FreeProxy() &#123; &#125; /** * 爬取 http://www.xicidaili.com/nn/ 的免费代理 * @return */ @Async private Future&lt;String&gt; getXicidaili()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.xicidaili.com/nn/ 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.XICI_URL, Constants.XICI_PAGE, Constants.XICI_PAGE_SUF, Constants.XICI_1Feature, Constants.XICI_2Feature, Constants.XICI_IPIndex, Constants.XICI_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.xicidaili.com/nn/ 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.xicidaili.com/ 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; /** * 爬取 http://www.66ip.cn/ 的免费代理 * @return */ @Async private Future&lt;String&gt; getIp66()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.66ip.cn/ 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.IP66_URL, Constants.IP66_PAGE, Constants.IP66_PAGE_SUF, Constants.IP66_1Feature, Constants.IP66_2Feature, Constants.IP66_IPIndex, Constants.IP66_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.66ip.cn/ 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.66ip.cn/ 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; /** * 爬取 http://www.nianshao.me 的免费代理 * @return */ @Async public Future&lt;String&gt; getNiaoshao()&#123; long start = System.currentTimeMillis(); log.info("开始爬取：http://www.nianshao.me 代理"); HashSet&lt;ProxyIP&gt; freeProxyIp = ProxyUtil.getFreeProxyIp(Constants.NIANSHAO_URL, Constants.NIANSHAO_PAGE, Constants.NIANSHAO_PAGE_SUF, Constants.NIANSHAO_1Feature, Constants.NIANSHAO_2Feature, Constants.NIANSHAO_IPIndex, Constants.NIANSHAO_PostIndex); ipSet.addAll(freeProxyIp); log.info("爬取：http://www.nianshao.me 代理 结束"); long end = System.currentTimeMillis(); return new AsyncResult&lt;&gt;("http://www.nianshao.me 爬取结束，耗时:"+(end-start)+"毫秒"); &#125; public void Train()&#123; long start = System.currentTimeMillis(); log.info("爬取代理任务开始，开始时间："+start); Future&lt;String&gt; xicidaili = getXicidaili(); Future&lt;String&gt; ip66 = getIp66(); while (true)&#123; if (getXicidaili().isDone() &amp;&amp; getIp66().isDone() &amp;&amp; getNiaoshao().isDone()) &#123; break; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; long end = System.currentTimeMillis(); log.info("爬取代理任务结束，结束时间："+end); log.info("任务全部完成总耗时"+(end-start)+"毫秒"); &#125; public HashSet&lt;ProxyIP&gt; GetAllIpProxy()&#123; Train(); return ipSet; &#125;&#125; python123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# -*- coding: utf-8 -*-from utils.configUtil import constantfrom utils.spiderUtil import getFreeProxyimport concurrent.futuresimport datetimefrom utils.logUtil import Logclass GetWebProxy(object): """收集互联网的零散IP""" def __init__(self): super(GetWebProxy, self).__init__() self.cons = constant() self.futures = set() def get_xicidaili(self): return getFreeProxy( self.cons.xicidaili_url, self.cons.xicidaili_page, self.cons.xicidaili_page_suf, self.cons.xicidaili_1Feature, self.cons.xicidaili_2Feature, self.cons.xicidaili_ip_index, self.cons.xicidaili_post_index ) def get_ip66(self): return getFreeProxy( self.cons.ip66_url, self.cons.ip66_page, self.cons.ip66_page_suf, self.cons.ip66_1Feature, self.cons.ip66_2Feature, self.cons.ip66_ip_index, self.cons.ip66_post_index ) def get_nianshao(self): return getFreeProxy( self.cons.ip66_url, self.cons.ip66_page, self.cons.ip66_page_suf, self.cons.ip66_1Feature, self.cons.ip66_2Feature, self.cons.ip66_ip_index, self.cons.ip66_post_index ) def contro_func(self, task_func): return task_func def train(self): start_time = datetime.datetime.now() with concurrent.futures.ThreadPoolExecutor(max_workers=8) as exeutor: tasks = [self.get_xicidaili(), self.get_ip66(), self.get_nianshao()] future_task = &#123;exeutor.submit(self.contro_func, task): task for task in tasks&#125; for future in concurrent.futures.as_completed(future_task): # ip_ports = future_task[future] self.futures.update(set(future.result())) end_time = datetime.datetime.now() print("耗时：", (end_time-start_time)) # range(1, 10):耗时：耗时： 0:00:00.297792 range(1, 100000) 耗时： 0:00:00.402069if __name__ == '__main__': g = GetWebProxy() g.train() print(g.futures)]]></content>
      <categories>
        <category>-日常开发</category>
      </categories>
      <tags>
        <tag>-并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGD、SGD和MBGD的一些区别]]></title>
    <url>%2F2017%2F09%2F12%2FBGD%E3%80%81SGD%E5%92%8CMBGD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[梯度下降(Batch gradient descent)–BGD123456789101112131415161718192021# 梯度下降(Batch gradient descent)--BGDdef batch_gradient_descent(x, y, learn_rate, epoches): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ theta = np.array([0.0, 0.0]) for i in range(epoches): loss = [0.0, 0.0] # 全部的值带入，计算 梯度 m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 随机梯度下降(Stochastic gradient descent)–SGD12345678910111213141516171819202122232425262728293031323334353637383940414243# 这不是随机梯度，随机梯度是每迭代一次，数据就随机一次---但是这也是一种处理手段def stochastic_gradient_descent_false(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] return batch_gradient_descent(x, y, learn_rate, epoches)# 正确的随机梯度应该是这样def stochastic_gradient_descent_true(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ theta = np.array([0.0, 0.0]) for i in range(epoches): shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] # 随机之后的值，进行梯度计算 loss = [0.0, 0.0] m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 小批量梯度下降(Mini-batch gradient descent)–MBGD1234567891011121314151617181920212223242526272829def mini_batch_gradient_descent(x, y, learn_rate, epoches, mini_length): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :param mini_length: mini batch length :return: """ # 随机打乱----optional theta = np.array([0.0, 0.0]) # 随机打乱数据 ----optional shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:, 0] x = shufflle_data[:, 1:3] for i in range(epoches): # 0-min_length， mini_length+1 2mini_length, ....... 一小段，一小段距离用于一次优化迭代 loss = [0.0, 0.0] for j in range(0, len(y), mini_length): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / mini_length loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / mini_length # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] return theta 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199# -*- coding: utf-8 -*-# @Date : 2017/9/8# @Author : ryanbing (legotime@qq.com)import numpy as npimport matplotlib.pyplot as pltimport datetimerng = np.random.RandomState(1)x = 10 * rng.rand(500)y = 3 * x + 2 + rng.randn(500)# plt.scatter(x, y)# plt.show()# 找出 y = wx + b 中的w 和 b, 正确的应该是 w = 3, b = 2# 我们在计算的时候其看成 y = WX 其中 W= [w, b], X = [x, 1].T# 梯度下降(Batch gradient descent)--BGDdef batch_gradient_descent(x, y, learn_rate, epoches): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() theta = np.array([0.0, 0.0]) for i in range(epoches): loss = [0.0, 0.0] # 全部的值带入，计算 梯度 m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, theta# 这不是随机梯度，随机梯度是每迭代一次，数据就随机一次---但是这也是一种处理手段def stochastic_gradient_descent_false(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] end_time = datetime.datetime.now() return end_time - start_time, batch_gradient_descent(x, y, learn_rate, epoches)# 正确的随机梯度应该是这样def stochastic_gradient_descent_true(x, y, learn_rate, epoches, stochastic_rate): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :return: """ start_time = datetime.datetime.now() theta = np.array([0.0, 0.0]) for i in range(epoches): shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) stochastic_count = int(len(y) * stochastic_rate) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:stochastic_count, 0] x = shufflle_data[:stochastic_count, 1:3] # 随机之后的值，进行梯度计算 loss = [0.0, 0.0] m = len(y) for j in range(m): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / m loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / m # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, theta# 小批量梯度下降(Mini-batch gradient descent)--MBGDdef mini_batch_gradient_descent(x, y, learn_rate, epoches, mini_length): """ :param x: 输入的x :param y: 输入的y :param learn_rate: 学习率 :param epoches: 迭代次数 :param mini_length: mini batch length :return: """ start_time = datetime.datetime.now() # 随机打乱----optional theta = np.array([0.0, 0.0]) # 随机打乱数据 ----optional shufflle_data = np.column_stack((y, x)) np.random.shuffle(shufflle_data) # 然后随机取一些数据进行梯度优化， 比如取随机100条数据 y = shufflle_data[:, 0] x = shufflle_data[:, 1:3] for i in range(epoches): # 0-min_length， mini_length+1 2mini_length, ....... 一小段，一小段距离用于一次优化迭代 loss = [0.0, 0.0] for j in range(0, len(y), mini_length): loss[0] = loss[0] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) * x[j, 0] / mini_length loss[1] = loss[1] + (theta[0] * x[j, 0] + theta[1] * x[j, 1] - y[j]) / mini_length # 更新 theta theta[0] = theta[0] - learn_rate * loss[0] theta[1] = theta[1] - learn_rate * loss[1] end_time = datetime.datetime.now() return end_time - start_time, thetadef contro_func(func, **kwargs): """ :param func: 函数 :param kwargs: func 中需要的参数 :return: """ x = kwargs.get('x', None) y = kwargs.get('y', None) learn_rate = kwargs.get('learn_rate', None) epoches = kwargs.get('epoches', None) stochastic_rate = kwargs.get('stochastic_rate', None) mini_length = kwargs.get('mini_length', None) # change the value is args is not num if stochastic_rate is not None: return func(x, y, learn_rate, epoches, stochastic_rate) if mini_length is not None: return func(x, y, learn_rate, epoches, mini_length) return func(x, y, learn_rate, epoches)def show_trend(): # 画出收敛的的图像和收敛对应的时间 rng = np.random.RandomState(1) x = 10 * rng.rand(500) x = np.array([x, np.ones(500)]).T y = 3 * x + 2 + rng.randn(500) learn_rate = 0.01 stochastic_rate = 0.4 mini_length = 10 for j in [batch_gradient_descent, stochastic_gradient_descent_false, stochastic_gradient_descent_true, mini_batch_gradient_descent]: tmp = [] for epoches in [1, 10, 100, 1000, 10000, 100000]: tmp.append(contro_func(i, x=x, y=y, learn_rate=learn_rate, stochastic_rate=stochastic_rate, mini_length=mini_length, epoches=epoches))if __name__ == '__main__': # test(func=func, x=1, y=2, learn_rate=3, epoches=4, stochastic_rate=5) # print(batch_gradient_descent(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100000)) # [ 1.14378512 0.17288215] # [ 3.18801281 0.50870366] # [ 3.18602557 0.806018 ] # [ 3.03276102 1.84267445] # [ 3.01449298 1.96623647] # [ 3.01449298 1.96623647] # print(stochastic_gradient_descent_false(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100,stochastic_rate=0.4)) # [ 1.11939055 0.16949282] # [ 3.19877639 0.50404936] # [ 3.20921332 0.78698163] # [ 3.04720128 1.82412805] # [ 3.01920995 1.89883629] # [ 2.98281143 2.15226071] # print(stochastic_gradient_descent_true(np.array([x, np.ones(50000)]).T, y, learn_rate=0.01, epoches=1000,stochastic_rate=1)) # print(mini_batch_gradient_descent(np.array([x, np.ones(500)]).T, y, learn_rate=0.01, epoches=100, mini_length=10)) # [ 0.94630842 0.14845568] # [ 0.8811451 0.15444328] # [ 3.18337012 0.51049921] # [ 3.14833317 0.79174635] # [ 3.03507147 1.87931184]]]></content>
      <categories>
        <category>-机器学习</category>
      </categories>
      <tags>
        <tag>-参数优化</tag>
      </tags>
  </entry>
</search>
